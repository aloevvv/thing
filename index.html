<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Adventuror</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: darkgreen;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: sans-serif;
      transition: background-color 2s ease-in-out;
    }

    #gameArea {
      position: relative;
      width: 600px;
      height: 400px;
      border: 2px solid white;
      overflow: hidden;
      margin-bottom: 10px;
    }
    #coordDisplay {
  position: absolute;
  top: 10px;
  right: 10px;
  color: white;
  font-size: 16px;
  font-weight: bold;
  text-shadow: 1px 1px 2px black;
  z-index: 30;
}
    #box {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: white;
      transition: left 0.1s linear, top 0.1s linear;
      z-index: 10;
    }

    /* Obstacle styles */
    .tree, .rock, .gold, .diamond, .berrybush, .craftingtable {
      position: absolute;
      width: 40px;
      height: 40px;
      box-sizing: border-box;
    }
    .tree { background-color: green; }
    .rock { background-color: gray; }
    .gold { background-color: gold; }
    .diamond { background-color: cyan; }
    .berrybush { background-color: darkred; border-radius: 50%; }
    .craftingtable { background-color: #8b4513; border: 2px solid #5c2e0d; } /* Brown table */
    .plot {
  position: absolute;
  width: 40px;
  height: 40px;
  background-color: #654321; /* brown dirt */
  border: 2px solid #3e2a14; /* darker outline */
  box-sizing: border-box;
  z-index: 1; /* keep it below player */
}
.plot.planted {
  background-color: #ccac81; /* planted state */
}
.plot.ready {
  background-color: #deb680; /* ready to harvest */
}
    .furnace {
  position: absolute;
  width: 40px;
  height: 40px;
  background-color: #444;    
  border: 2px solid #222;      
  box-sizing: border-box;
}
    .chest {
  position: absolute;
  width: 40px;
  height: 40px;
  background-color: #a67c52;
  border: 2px solid #5c3d1e;
  box-sizing: border-box;
}

    .firepit {
  position: absolute;
  width: 40px;
  height: 40px;
  background-color: #361919;    
  border: 2px solid #000000;      
  box-sizing: border-box;
}
    .firepit.lit {
  background-color: red; 
  box-shadow: 0 0 10px red;
}


    /* Enemy styles */
    .enemy {
      position: absolute;
      width: 40px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 10px;
      transition: left 0.4s linear, top 0.4s linear;
      z-index: 5;
      border: 2px solid red;
      box-sizing: border-box;
    }
    .wolf { background-color: brown; }
    .bear { background-color: black; }
    .fox { background-color: orange; }
    .polarBear { background-color: white; }

    /* UI Overlay and Inventory styles remain the same */
    #uiContainer { display: flex; flex-direction: column; width: 600px; }
    .status-bar-container { width: 100%; height: 20px; background-color: rgba(0, 0, 0, 0.5); border: 1px solid white; margin-bottom: 5px; position: relative; }
    .status-bar-fill { height: 100%; transition: width 0.3s ease-out; }
    .status-bar-label { position: absolute; top: 0; left: 0; width: 100%; text-align: center; line-height: 20px; font-size: 12px; text-shadow: 1px 1px 1px black; }
    #hp-fill { background-color: red; }
    #hunger-fill { background-color: orange; }
    #inventory { display: grid; grid-template-columns: repeat(9, 60px); gap: 5px; width: 600px; height: 60px; background-color: rgba(0, 0, 0, 0.5); padding: 5px; border: 2px solid white; }
    .inv-slot { width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.1); border: 1px solid white; position: relative; cursor: pointer; }
    .inv-slot:hover { background-color: rgba(255, 255, 255, 0.3); }
    .item-icon { width: 80%; height: 80%; margin: 10% auto; }
    .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: white; text-shadow: 1px 1px 1px black; }
    .equipped { border: 2px solid cyan; } /* Highlight equipped items */
#controlsPopup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: saddlebrown; /* brown background */
  color: white;                  /* white text */
  padding: 20px;
  border: 3px solid white;
  border-radius: 8px;
  font-family: sans-serif;
  font-size: 14px;
  z-index: 100;
  display: none; /* hidden by default */
  width: 300px;
  text-align: left;
}

#controlsPopup h2 {
  margin-top: 0;
  text-align: center;
}


    /* Crafting Area UI */
    #craftingArea {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 20;
  display: grid;
  grid-auto-flow: column;  
  grid-template-rows: repeat(15, auto); 
  gap: 5px;
}


    .craft-option {
        width: 120px;
        height: 30px;
        background-color: rgba(0, 0, 0, 0.7);
        border: 1px solid white;
        display: flex;
        align-items: center;
        padding: 5px;
        cursor: pointer;
        font-size: 12px;
    }

    .craft-option:hover {
        background-color: rgba(255, 255, 255, 0.2);
    }

    .craft-icon {
        width: 20px;
        height: 20px;
        margin-right: 5px;
    }
  </style>
</head>
<body>
  <div id="craftingArea">
      <!-- Crafting options appear here -->
  </div>
  <div id="coordDisplay">0,0</div>
  
  <div id="gameArea">
    <div id="box"></div>
  </div>

  <div id="uiContainer">
    <div class="status-bar-container">
        <div id="hp-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HP: <span id="hp-value">100</span>/100</div>
    </div>
    <div class="status-bar-container">
        <div id="hunger-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HUNGER: <span id="hunger-value">100</span></div>
    </div>
    <div class="status-bar-container">
  <div id="temp-fill" class="status-bar-fill"></div>
  <div class="status-bar-label">TEMPERATURE: <span id="temp-value">100</span></div>
</div>
    <div id="inventory"></div>
  </div>

  <div id="chestPopup" style="
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  display: none;
  background-color: rgba(0,0,0,0.7);
  border: 2px solid white;
  padding: 10px;
  width: 200px;
  display: flex;
  justify-content: space-around;
">
  <div class="chest-slot" data-index="0"></div>
  <div class="chest-slot" data-index="1"></div>
  <div class="chest-slot" data-index="2"></div>
</div>

  
  <div id="controlsPopup">
  <h2>Controls</h2>
  <ul>
    <li>Arrow keys â†’ Move</li>
    <li>Q â†’ Show/Hide this popup</li>
    <li>X â†’ Plant seeds</li>
    <li>Click â†’ Fuel fire pits</li>
    <li>Space â†’ Punch</li>
    <!-- Add more controls here -->
  </ul>
</div>


  <script>
        // --- DOM ELEMENT REFERENCES ---
    const gameArea = document.getElementById("gameArea");
    const box = document.getElementById("box");
    const inventoryEl = document.getElementById("inventory");
    const craftingAreaEl = document.getElementById("craftingArea");
    const gameLogEl = document.getElementById("gameLog");
    const hpFillEl = document.getElementById("hp-fill");
    const hpValueEl = document.getElementById("hp-value"); 
    const hungerFillEl = document.getElementById("hunger-fill");
    const hungerValueEl = document.getElementById("hunger-value");
    
    // --- CONFIGS AND STATE (Same as before) ---
    const step = 20; 
    const INVENTORY_SIZE = 9; 
    const GRID_SIZE = 40;

    let boxX = 280; 
    let boxY = 180; 
    let roomX = 0; 
    let roomY = 0; 
    const rooms = {}; 
    let lastHitTime = 0;

    const player = {
  hp: 100,
  maxHp: 100,
  hunger: 100,
  maxHunger: 100,
  temp: 100,      
  maxTemp: 100,   
  inventory: {},
  equipped: {
    pickaxe: null,
    helmet: null,
    sword: null,
    backpackUpgrade: false
  }
};


    const resourceConfig = {
  tree: { max: 30, regen: 5000, color: 'green', type: 'material' },
  rock: { max: 20, regen: 10000, color: 'gray', type: 'material', toolNeeded: 'w-pickaxe' },
  gold: { max: 10, regen: 20000, color: 'gold', type: 'material', toolNeeded: 'stone-axe' },
  diamond: { max: 10, regen: 20000, color: 'cyan', type: 'material', toolNeeded: 'gold-axe' },
  berrybush: { max: 6, regen: 8000, color: 'darkred', type: 'food', foodValue: 10 }
};
    // Add new items and their colors
    resourceConfig['meat'] = { color: 'pink', type: 'food', foodValue: 20 };
    resourceConfig['fur'] = { color: 'white', type: 'material' };
    resourceConfig['w-pickaxe'] = { color: '#8b4513', type: 'tool', equip: 'pickaxe' }; 
    resourceConfig['w-helm'] = { color: '#8b4513', type: 'armor', equip: 'helmet', defense: 1 };
    resourceConfig['w-sword'] = { color: '#8b4513', type: 'weapon', equip: 'sword', damageBoost: 5 };
    resourceConfig['w-pickaxe'] = { color: '#8b4513', type: 'tool', equip: 'pickaxe', harvestLevel: 1 };
    resourceConfig['furnace'] = { color: '#444', type: 'placeable' };
    resourceConfig['firepit'] = { color: '#444', type: 'placeable' };
    resourceConfig['chest'] = { color: '#a67c52', type: 'placeable' };
    resourceConfig['stone-axe'] = { color: '#7f7f7f', type: 'tool', equip: 'pickaxe', harvestLevel: 2 };
    resourceConfig['stone-sword'] = { color: '#7f7f7f', type: 'weapon', equip: 'sword', damageBoost: 10 };
    resourceConfig['stone-helm'] = { color: '#7f7f7f', type: 'armor', equip: 'helmet', defense: 2 };
    resourceConfig['gold-axe'] = { color: 'gold', type: 'tool', equip: 'pickaxe', harvestLevel: 3 };
    resourceConfig['gold-sword'] = { color: 'gold', type: 'weapon', equip: 'sword', damageBoost: 15 };
    resourceConfig['gold-helm'] = { color: 'gold', type: 'armor', equip: 'helmet', defense: 3 };
    resourceConfig['diamond-axe'] = { color: 'cyan', type: 'tool', equip: 'pickaxe', harvestLevel: 4 };
    resourceConfig['diamond-sword'] = { color: 'cyan', type: 'weapon', equip: 'sword', damageBoost: 20 };
    resourceConfig['diamond-helm'] = { color: 'cyan', type: 'armor', equip: 'helmet', defense: 4 };
    resourceConfig['craftingtable'] = { color: '#8b4513', type: 'placeable' };
    resourceConfig['shovel'] = { 
  color: '#a0522d', 
  type: 'tool', 
  equip: 'pickaxe',
  harvestLevel: 0
};
resourceConfig['wheat-seed'] = { color: 'yellow', type: 'material' };
resourceConfig['dirt'] = { color: '#794f4f', type: 'material' };
resourceConfig['wheat'] = { color: 'goldenrod', type: 'material' };
resourceConfig['backpack'] = { color: '#853c16', type: 'material' };
resourceConfig['plot'] = { color: '#654321', type: 'placeable' };
resourceConfig['bread'] = { color: '#bc7f2e', type: 'food', foodValue: 30 };
resourceConfig['cooked-meat'] = { color: '#6b1616', type: 'food', foodValue: 25 };



    const enemyConfig = {
        wolf: { hp: 200, damage: 10, speed: 30, range: 300, drops: { meat: 1 }, spawnChance: 0.10 },
        bear: { hp: 350, damage: 20, speed: 15, range: 300, drops: { meat: 2, fur: 1 }, spawnChance: 0.10 },
        fox: { hp: 200, damage: 10, speed: 40, range: 300, drops: { meat: 1 }, spawnChance: 0.10 },
        polarBear: { hp: 500, damage: 25, speed: 30, range: 400, drops: { meat: 2, fur: 2 }, spawnChance: 0.10 } 
    };

    // Crafting Recipes
    const recipes = {
        'w-pickaxe': { costs: { tree: 20 }, requiresTable: false },
        'w-helm': { costs: { tree: 50 }, requiresTable: false },
        'w-sword': { costs: { tree: 35 }, requiresTable: false },
        'craftingtable': { costs: { tree: 30 }, requiresTable: false },
        'furnace': { costs: { rock: 45 }, requiresTable: true },
        'firepit': { costs: { tree: 60, rock: 30 }, requiresTable: true },
        'stone-axe': { costs: { tree: 40, rock: 30 }, requiresTable: true },
        'shovel': { costs: { tree: 30, rock: 30 }, requiresTable: true },
        'stone-sword': { costs: { tree: 50, rock: 40 }, requiresTable: true },
        'stone-helm': { costs: { tree: 30, rock: 75 }, requiresTable: true },
        'gold-axe': { costs: { tree: 50, gold: 40 }, requiresTable: true },
        'gold-sword': { costs: { tree: 50, rock: 40, gold: 50 }, requiresTable: true },
        'gold-helm': { costs: { rock: 50, gold: 60 }, requiresTable: true },
        'chest': { costs: { tree : 75, gold: 10 }, requiresTable: true },
        'diamond-axe': { costs: { tree: 60, diamond: 50 }, requiresTable: true },
        'diamond-sword': { costs: { rock: 50, gold: 40, diamond: 60 }, requiresTable: true },
        'diamond-helmet': { costs: { rock: 60, gold: 50, diamond: 70 }, requiresTable: true },
        'backpack': { costs: { tree: 5 }, requiresTable: true },
        'plot': { costs: { tree: 20, dirt: 60 }, requiresTable: true },
        'bread': { costs: { wheat: 3 }, requiresFurnace: true },
        'cooked-meat': { costs: { meat: 1 }, requiresFurnace: true },
    };

    // --- UI Update Functions ---
    function updateHPUI() {
        hpValueEl.textContent = player.hp;
        const percent = (player.hp / player.maxHp) * 100;
        hpFillEl.style.width = percent + "%";
        if (player.hp <= 0) alert("You died!");
    }
    function updateHungerUI() {
        hungerValueEl.textContent = player.hunger;
        const percent = (player.hunger / player.maxHunger) * 100;
        hungerFillEl.style.width = percent + "%";
    }
    function updateInventoryUI() {
  inventoryEl.innerHTML = '';
  const sortedItems = Object.keys(player.inventory).sort().map(type => [type, player.inventory[type]]);

  for (let i = 0; i < getInventorySize(); i++) {
    const slot = document.createElement("div");
    slot.className = "inv-slot";
    slot.dataset.index = i;

    if (i < sortedItems.length) {
      const [type, count] = sortedItems[i];
      if (count > 0) {
        const icon = document.createElement("div");
        icon.className = `item-icon ${type}`;
        icon.style.backgroundColor = resourceConfig[type].color;

        // ðŸ”‘ Add hover text
        icon.title = type; // shows "w-pickaxe", "w-sword", etc.
        slot.title = type; // also works if you hover anywhere in the slot

        slot.appendChild(icon);

        const countSpan = document.createElement("span");
        countSpan.className = "item-count";
        countSpan.textContent = count;
        slot.appendChild(countSpan);

        slot.dataset.type = type;

        const visibleSize = backpackVisible ? getInventorySize() : INVENTORY_SIZE;

        const itemConfig = resourceConfig[type];
        if (itemConfig && itemConfig.equip && player.equipped[itemConfig.equip] === type) {
          slot.classList.add('equipped');
        }
      }
    }
    inventoryEl.appendChild(slot);
  }
}
    function getInventorySize() {
  return INVENTORY_SIZE + (player.backpackUpgrade ? 4 : 0);
}

    function updateCraftingUI() {
  craftingAreaEl.innerHTML = '';
  const nearbyTable = isNearCraftingTable();
  const nearbyFurnace = isNearFurnace();

  for (const itemName in recipes) {
    const recipe = recipes[itemName];
    if (recipe.requiresTable && !nearbyTable) continue;
    if (recipe.requiresFurnace && !nearbyFurnace) continue;

    let canCraft = true;
    for (const resource in recipe.costs) {
      if (!player.inventory[resource] || player.inventory[resource] < recipe.costs[resource]) {
        canCraft = false;
        break;
      }
    }

    if (canCraft) {
      const craftOption = document.createElement("div");
      craftOption.className = "craft-option";
      craftOption.dataset.type = itemName;
      craftOption.addEventListener('click', () => craftItem(itemName));

      const icon = document.createElement("div");
      icon.className = "craft-icon";
      icon.style.backgroundColor = resourceConfig[itemName].color;
      craftOption.appendChild(icon);

      const label = document.createElement("span");
      label.textContent = itemName;
      craftOption.appendChild(label);

      craftingAreaEl.appendChild(craftOption);
    }
  }
}


    // --- Interaction Logic ---

    // Eating/Equipping logic on inventory click
    inventoryEl.addEventListener('click', (event) => {
        const clickedSlot = event.target.closest('.inv-slot');
        if (clickedSlot && clickedSlot.dataset.type) {
            const itemType = clickedSlot.dataset.type;
            const config = resourceConfig[itemType];

            if (config.type === 'food') {
                eatItem(itemType);
            } else if (config.equip) {
                toggleEquip(itemType, config.equip);
            }
        }
    });
    
    function toggleEquip(itemType, slotName) {
        if (player.equipped[slotName] === itemType) {
            // Unequip
            player.equipped[slotName] = null;
        } else {
            // Equip new item
            player.equipped[slotName] = itemType;
        }
        // Update UI to reflect changes (highlighting equipped slots)
        updateInventoryUI();
    }
    
    let backpackVisible = false;

document.addEventListener("keydown", (event) => {
  if (event.code === "KeyI" && player.backpackUpgrade) {
    backpackVisible = !backpackVisible;
    updateInventoryUI();
  }
});


    function craftItem(itemType) {
  const recipe = recipes[itemType];
  if (!recipe) return;

  // Verify costs
  for (const resource in recipe.costs) {
    if (!player.inventory[resource] || player.inventory[resource] < recipe.costs[resource]) {
      console.log("Cannot craft, missing resources.");
      return;
    }
  }

  // Deduct costs
  for (const resource in recipe.costs) {
    player.inventory[resource] -= recipe.costs[resource];
    if (player.inventory[resource] <= 0) delete player.inventory[resource];
  }

  // Special case: backpack upgrade
  if (itemType === 'backpack') {
    player.backpackUpgrade = true;
    console.log("Backpack crafted! Inventory expanded by 4 slots.");
  } else if (itemType === 'furnace') {
    placeFurnace(itemType);
  } else if (itemType === 'plot') {
    placePlot();
  } else if (itemType === 'firepit') {
    placeFirePit();
  } else if (resourceConfig[itemType].type === 'placeable') {
    placeCraftingTable(itemType);
  } else {
    collectResource(itemType, 1);
  }

  updateInventoryUI();
  updateCraftingUI();
}

    
    function placeCraftingTable(type) {
        // Find an empty spot near the player? For now, just add an obstacle to the current room data
        // This is a simple implementation for now.
        const currentRoomData = rooms[`${roomX},${roomY}`];
        const newTable = document.createElement("div");
        newTable.className = type;
        // Simple placement near player for now, collision detection would be better
        newTable.style.left = (boxX + GRID_SIZE) + "px"; 
        newTable.style.top = boxY + "px";

        // Add to room's obstacle list and DOM
        currentRoomData.obstacles.push(newTable);
        gameArea.appendChild(newTable);
        // Note: placed objects currently don't have regen intervals/datasets, they are permanent once placed.
    }
    function placePlot() {
  const currentRoomData = rooms[`${roomX},${roomY}`];
  const plot = document.createElement("div");
  plot.className = "plot";
  plot.dataset.type = "plot"; 
  plot.dataset.state = "empty";
  plot.style.left = (boxX + GRID_SIZE) + "px";
  plot.style.top = boxY + "px";
  currentRoomData.obstacles.push(plot);
  gameArea.appendChild(plot);
}

function placeFurnace(type) {
  const currentRoomData = rooms[`${roomX},${roomY}`];
  const furnace = document.createElement("div");
  furnace.className = type;
  furnace.dataset.type = "furnace"; 
  furnace.style.left = (boxX + GRID_SIZE) + "px";
  furnace.style.top = boxY + "px";
  currentRoomData.obstacles.push(furnace);
  gameArea.appendChild(furnace);
}
function placeFirePit() {
  const currentRoomData = rooms[`${roomX},${roomY}`];
  const pit = document.createElement("div");
  pit.className = "firepit";
  pit.dataset.type = "firepit";
  pit.dataset.fuel = 0; // how many ticks left
  pit.style.left = (boxX + GRID_SIZE) + "px";
  pit.style.top = boxY + "px";
  currentRoomData.obstacles.push(pit);
  gameArea.appendChild(pit);

 
  pit.addEventListener("click", () => {
  let treesToUse = parseInt(prompt("How many trees to fuel the pit?"), 10);

  // Clamp negative values to 0
  if (isNaN(treesToUse) || treesToUse < 0) {
    treesToUse = 0;
  }

  if (player.inventory['tree'] >= treesToUse) {
    player.inventory['tree'] -= treesToUse;
    pit.dataset.fuel = parseInt(pit.dataset.fuel) + treesToUse;
    updateInventoryUI();
  }
});


  // burn loop
  setInterval(() => {
    if (pit.dataset.fuel > 0) {
      pit.dataset.fuel--;
    }
  }, 3000); 
}

function placeChest() {
  const currentRoomData = rooms[`${roomX},${roomY}`];
  const chest = document.createElement("div");
  chest.className = "chest";
  chest.dataset.type = "chest";
  chest.dataset.contents = JSON.stringify([null, null, null]); // 3 slots
  chest.style.left = (boxX + GRID_SIZE) + "px";
  chest.style.top = boxY + "px";

  currentRoomData.obstacles.push(chest);
  gameArea.appendChild(chest);
}

    
    function isNearCraftingTable() {
        const obstacles = rooms[`${roomX},${roomY}`].obstacles;
        for (const obs of obstacles) {
            if (obs.classList.contains('craftingtable')) {
                const ox = parseInt(obs.style.left);
                const oy = parseInt(obs.style.top);
                const dx = Math.abs(boxX - ox);
                const dy = Math.abs(boxY - oy);
                // Check if within a reasonable range (e.g., 2 grid sizes)
                if (dx < GRID_SIZE * 2 && dy < GRID_SIZE * 2) {
                    return true;
                }
            }
        }
        return false;
    }
    function isNearFurnace() {
  const obstacles = rooms[`${roomX},${roomY}`].obstacles;
  for (const obs of obstacles) {
    if (obs.classList.contains('furnace')) {
      const ox = parseInt(obs.style.left);
      const oy = parseInt(obs.style.top);
      const dx = Math.abs(boxX - ox);
      const dy = Math.abs(boxY - oy);
      if (dx < GRID_SIZE * 2 && dy < GRID_SIZE * 2) {
        return true;
      }
    }
  }
  return false;
}
    function nearFirePit() {
  const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
  for (const obs of obstacles) {
    if (obs.dataset.type === "firepit" && parseInt(obs.dataset.fuel) > 0) {
      const ox = parseInt(obs.style.left);
      const oy = parseInt(obs.style.top);
      if (Math.abs(boxX - ox) < GRID_SIZE * 2 && Math.abs(boxY - oy) < GRID_SIZE * 2) {
        return true;
      }
    }
  }
  return false;
}
    function nearChest() {
  const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
  for (const obs of obstacles) {
    if (obs.dataset.type === "chest") {
      const ox = parseInt(obs.style.left);
      const oy = parseInt(obs.style.top);
      if (Math.abs(boxX - ox) < GRID_SIZE * 2 && Math.abs(boxY - oy) < GRID_SIZE * 2) {
        return obs;
      }
    }
  }
  return null;
    }


    function updateChestUI(chest) {
  const contents = JSON.parse(chest.dataset.contents);
  const slots = document.querySelectorAll("#chestPopup .chest-slot");

  slots.forEach((slot, i) => {
    slot.textContent = contents[i] ? contents[i] : "";
    slot.onclick = () => {
      if (contents[i]) {
        // take item back
        collectResource(contents[i], 1);
        contents[i] = null;
      } else {
        // put first inventory item in
        const invKeys = Object.keys(player.inventory);
        if (invKeys.length > 0) {
          const item = invKeys[0];
          player.inventory[item]--;
          if (player.inventory[item] <= 0) delete player.inventory[item];
          contents[i] = item;
        }
      }
      chest.dataset.contents = JSON.stringify(contents);
      updateInventoryUI();
      updateChestUI(chest);
    };
  });
}


    function eatItem(itemType) {
        const config = resourceConfig[itemType];
        if (config && config.type === 'food' && player.inventory[itemType] > 0) {
            player.inventory[itemType]--;
            player.hunger += config.foodValue;
            if (player.hunger > player.maxHunger) player.hunger = player.maxHunger;
            if (player.inventory[itemType] <= 0) delete player.inventory[itemType];
            updateHungerUI();
            updateInventoryUI();
        }
    }
    
   function collectResource(type, amount) {
  // If resource already exists, just add
  if (player.inventory[type]) {
    player.inventory[type] += amount;
  } else {
    // Count unique items
    const uniqueCount = Object.keys(player.inventory).length;
    if (uniqueCount >= getInventorySize()) {
      console.log("Inventory full! Cannot collect " + type);
      return; // Do not add new resource
    }
    player.inventory[type] = amount;
  }
  updateInventoryUI();
  updateCraftingUI();
}


    function damagePlayer(amount) {
        player.hp -= amount;
        lastHitTime = Date.now(); // IMPORTANT: resets hit timer
        updateHPUI();
    }

    // --- Game World Generation/Persistence ---
    function placeObstacle(type, count, obstacles) {
  const cfg = resourceConfig[type];
  const margin = 10; // minimum distance from edges

  for (let i = 0; i < count; i++) {
    const obs = document.createElement("div");
    obs.className = type;

    // Clamp spawn area to avoid corners
    const maxX = gameArea.offsetWidth - GRID_SIZE - margin;
    const maxY = gameArea.offsetHeight - GRID_SIZE - margin;
    const ox = Math.floor(Math.random() * (maxX - margin)) + margin;
    const oy = Math.floor(Math.random() * (maxY - margin)) + margin;

    obs.style.left = ox + "px";
    obs.style.top = oy + "px";
    obs.dataset.type = type;
    obs.dataset.amount = cfg.max;
    obs.style.backgroundColor = cfg.color;

    obstacles.push(obs);
  }
}


    function createEnemy(type, x, y) {
        const config = enemyConfig[type];
        const enemyEl = document.createElement("div");
        enemyEl.className = `enemy ${type}`;
        enemyEl.style.left = x + "px";
        enemyEl.style.top = y + "px";
        enemyEl.dataset.type = type;
        enemyEl.dataset.hp = config.hp;
        enemyEl.dataset.maxHp = config.hp;
        enemyEl.textContent = `${type} (${config.hp})`;
        return enemyEl;
    }

    function placeEnemies(enemies) {
  if (isTundra()) {
    if (Math.random() < enemyConfig.polarBear.spawnChance) {
      enemies.push(createEnemy('polarBear',
        Math.random() * (gameArea.offsetWidth - GRID_SIZE),
        Math.random() * (gameArea.offsetHeight - GRID_SIZE)));
    }
  } else {
        if (Math.random() < enemyConfig.wolf.spawnChance) enemies.push(createEnemy('wolf', Math.random() * (gameArea.offsetWidth - GRID_SIZE), Math.random() * (gameArea.offsetHeight - GRID_SIZE)));
        if (Math.random() < enemyConfig.bear.spawnChance) enemies.push(createEnemy('bear', Math.random() * (gameArea.offsetWidth - GRID_SIZE), Math.random() * (gameArea.offsetHeight - GRID_SIZE)));
        if (Math.random() < enemyConfig.fox.spawnChance) enemies.push(createEnemy('fox', Math.random() * (gameArea.offsetWidth - GRID_SIZE), Math.random() * (gameArea.offsetHeight - GRID_SIZE)));
    }
    }
    
    function generateRoom(rx, ry) {
      const key = `${rx},${ry}`;
      if (rooms[key]) return rooms[key];
      const roomData = { obstacles: [], enemies: [], intervals: [] };
      placeObstacle("tree", Math.floor(Math.random() * 3) + 2, roomData.obstacles);
      placeObstacle("rock", Math.floor(Math.random() * 2) + 1, roomData.obstacles);
      if (Math.random() < 0.25) placeObstacle("gold", 1, roomData.obstacles);
      if (Math.random() < 0.05) placeObstacle("diamond", 1, roomData.obstacles);
      placeObstacle("berrybush", Math.floor(Math.random() * 3) + 1, roomData.obstacles);
      placeEnemies(roomData.enemies);
      rooms[key] = roomData;
      return roomData;
    }
    function clearRoom() {
      const key = `${roomX},${roomY}`;
      const currentRoomData = rooms[key];
      if (currentRoomData) {
          currentRoomData.obstacles.forEach(child => { if (child.parentNode === gameArea) gameArea.removeChild(child); });
          currentRoomData.enemies.forEach(child => { if (child.parentNode === gameArea) gameArea.removeChild(child); });
          currentRoomData.intervals.forEach(clearInterval);
          currentRoomData.intervals = [];
      }
    }
    function loadRoom(rx, ry) {
  const roomData = generateRoom(rx, ry);
  roomData.obstacles.forEach(obs => {
    gameArea.appendChild(obs);

    // Only start regen for harvestable resources
    const type = obs.dataset.type;
    if (type && resourceConfig[type] && resourceConfig[type].regen) {
      const cfg = resourceConfig[type];
      const intervalId = setInterval(() => {
        let amt = parseInt(obs.dataset.amount);
        if (amt < cfg.max) obs.dataset.amount = amt + 1;
      }, cfg.regen);
      roomData.intervals.push(intervalId);
    }
  });

  roomData.enemies.forEach(enemy => {
    if (enemy.dataset.hp > 0) gameArea.appendChild(enemy);
  });

  updateCraftingUI();
}



    function checkObstacleCollision(x, y, obstacles) {
  const rect1 = {x, y, w: GRID_SIZE, h: GRID_SIZE};
  for (const item of obstacles) {
    if (item.parentNode === gameArea) {
      if (item.dataset.type === "plot") continue; // plots are walkable
      const ox = parseInt(item.style.left);
      const oy = parseInt(item.style.top);
      const rect2 = {x: ox, y: oy, w: GRID_SIZE, h: GRID_SIZE};
      if (rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x &&
          rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y) {
        return true;
      }
    }
  }
  return false;
}

    
    function updateCoordDisplay() {
  document.getElementById("coordDisplay").textContent = `${roomX},${roomY}`;
}


    function canMovePlayer(newX, newY) {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        return !checkObstacleCollision(newX, newY, currentRoomData.obstacles);
    }
    
    // --- Core Game Loops and Handlers ---

    // Initial setup
    loadRoom(roomX, roomY);
    updateHPUI();
    updateHungerUI();
    updateInventoryUI();
    updateCraftingUI();
    updateCoordDisplay();
    let isDay = true;
let cycleTimer = 0;

    function isTundra() {
  return roomY >= 30; // tundra starts at y=30
}


function startDayNightCycle() {
  updateDayNightUI();

  setInterval(() => {
    cycleTimer++;

    if (isDay && cycleTimer >= 40) { // 40 ticks * 3s = 120s
      isDay = false;
      cycleTimer = 0;
      updateDayNightUI();
    } else if (!isDay && cycleTimer >= 20) { // 20 ticks * 3s = 60s
      isDay = true;
      cycleTimer = 0;
      updateDayNightUI();
    }
  }, 3000); // tick every 3 seconds
}


function updateDayNightUI() {
  if (isTundra()) {
    document.body.style.backgroundColor = isDay ? "#c8e3ff" : "#7c8fc4"; // tundra colors
  } else {
    document.body.style.backgroundColor = isDay ? "darkgreen" : "#004026"; // forest colors
  }
}

    function updateTempUI() {
  document.getElementById("temp-value").textContent = player.temp;
  const percent = (player.temp / player.maxTemp) * 100;
  document.getElementById("temp-fill").style.width = percent + "%";
}


setInterval(() => {
  let loss;
  if (isTundra()) {
    loss = isDay ? 25 : 50; // tundra harsher
  } else {
    loss = isDay ? 2 : 30;  // normal biome
  }

  if (!nearFirePit()) {
    player.temp -= loss;
  } else {
    player.temp += 20;
    if (player.temp > player.maxTemp) player.temp = player.maxTemp;
  }

  if (player.temp <= 0) {
    damagePlayer(10);
    player.temp = 0;
  }

  updateTempUI();
}, 3000);



  
    setInterval(() => {
        if (player.hunger > 0) {
            player.hunger -= 5;
            if (player.hunger < 0) player.hunger = 0;
            updateHungerUI();
        }
    }, 10000);

    setInterval(() => {
        if (player.hunger === 0 && player.hp > 0) {
            damagePlayer(10);
        }
        
        // Healing logic: 5 HP every 3 seconds if not hit for 5s AND hunger > 70%
        if (Date.now() - lastHitTime >= 5000 && player.hunger > player.maxHunger * 0.70 && player.hp < player.maxHp) {
            player.hp += 5;
            if (player.hp > player.maxHp) player.hp = player.maxHp;
            updateHPUI();
        }
    }, 3000);


    // AI Update Loop (~0.5 seconds) - Enemies now phase through each other and player
    setInterval(() => {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        if (!currentRoomData) return;

        currentRoomData.enemies.forEach(enemy => {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) return;

            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);
            const dx = boxX - eX;
            const dy = boxY - eY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const config = enemyConfig[enemy.dataset.type];

            // Use larger range for detection
            if (distance < config.range) { 
                let moveX = 0;
                let moveY = 0;
                const enemyStep = config.speed;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = Math.sign(dx) * enemyStep;
                } else {
                    moveY = Math.sign(dy) * enemyStep;
                }
                
                let newEX = eX + moveX;
                let newEY = eY + moveY;

                // Check collision only against *obstacles* (walls), not other entities
                if (!checkObstacleCollision(newEX, newEY, currentRoomData.obstacles)) {
                    // Boundary check
                    if (newEX >= 0 && newEX <= gameArea.offsetWidth - GRID_SIZE &&
                        newEY >= 0 && newEY <= gameArea.offsetHeight - GRID_SIZE) {
                            enemy.style.left = newEX + "px";
                            enemy.style.top = newEY + "px";
                    }
                }
            }
        });
    }, 500);

    // Enemy Attack loop (Every 3 seconds, calls damagePlayer)
    setInterval(() => {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        if (!currentRoomData || player.hp <= 0) return;

        currentRoomData.enemies.forEach(enemy => {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) return;

            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);
            const config = enemyConfig[enemy.dataset.type];

            const dx = Math.abs(boxX - eX);
            const dy = Math.abs(boxY - eY);
            if (dx < GRID_SIZE && dy < GRID_SIZE) { 
                // Apply damage reduction from helmet if equipped
                let damageToDeal = config.damage;
                if (player.equipped.helmet && resourceConfig[player.equipped.helmet]) {
                    damageToDeal -= resourceConfig[player.equipped.helmet].defense;
                    if (damageToDeal < 0) damageToDeal = 0;
                }
                damagePlayer(damageToDeal);
            }
        });
    }, 3000);


    // Movement Handler - Added updateCraftingUI call here
   
   

function updateChestPopup() {
  const chest = nearChest();
  const popup = document.getElementById("chestPopup");

  if (chest) {
    popup.style.display = "flex";
    updateChestUI(chest);
  } else {
    popup.style.display = "none";
  }
}

// Arrowâ€‘key movement handler
document.addEventListener("keydown", (event) => {
  let newX = boxX;
  let newY = boxY;
  let roomChanged = false;

  if (event.key === "ArrowUp") newY -= step;
  else if (event.key === "ArrowDown") newY += step;
  else if (event.key === "ArrowLeft") newX -= step;
  else if (event.key === "ArrowRight") newX += step;
  else if (event.code !== "Space") return;

  // room change logic...
  if (roomChanged) {
    loadRoom(roomX, roomY);
    updateCoordDisplay();
    updateDayNightUI();
  }

  if (canMovePlayer(newX, newY)) {
    boxX = newX;
    boxY = newY;
    box.style.left = boxX + "px";
    box.style.top = boxY + "px";
    updateCraftingUI();
    updateChestPopup();
  }
});
    inventoryEl.addEventListener('contextmenu', (event) => {
  event.preventDefault(); // Prevent browser menu
  const clickedSlot = event.target.closest('.inv-slot');
  if (clickedSlot && clickedSlot.dataset.type) {
    const itemType = clickedSlot.dataset.type;
    // Remove entire stack
    delete player.inventory[itemType];
    console.log(itemType + " stack discarded.");
    updateInventoryUI();
    updateCraftingUI();
  }
});

    const controlsPopup = document.getElementById("controlsPopup");

document.addEventListener("keydown", (event) => {
  if (event.code === "KeyQ") {
    // Toggle popup visibility
    if (controlsPopup.style.display === "none" || controlsPopup.style.display === "") {
      controlsPopup.style.display = "block";
    } else {
      controlsPopup.style.display = "none";
    }
  }
});


document.addEventListener("keydown", (event) => {
  if (event.code === "KeyX") {
    const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
    for (const obs of obstacles) {
      if (obs.dataset.type === "plot") {
        const ox = parseInt(obs.style.left);
        const oy = parseInt(obs.style.top);

        // check proximity: player must be standing on/near the plot
        if (Math.abs(boxX - ox) < GRID_SIZE && Math.abs(boxY - oy) < GRID_SIZE) {

  
          if (obs.dataset.state === "empty" && player.inventory['wheat-seed'] > 0) {
            player.inventory['wheat-seed']--;
            obs.dataset.state = "planted";
            obs.classList.add("planted");
            setTimeout(() => {
              obs.dataset.state = "ready";
              obs.classList.remove("planted");
              obs.classList.add("ready");
            }, 80000);
          } else if (obs.dataset.state === "ready") {
            collectResource('wheat', 1);
            collectResource('wheat-seed', 1);
            obs.dataset.state = "empty";
            obs.classList.remove("ready");
          }

        }
      }
    }
  }
});
    // Punch
  document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
        const enemies = rooms[`${roomX},${roomY}`].enemies || [];
        let punchDamage = 10; 
        if (player.equipped.sword && resourceConfig[player.equipped.sword]) punchDamage += resourceConfig[player.equipped.sword].damageBoost;

        const checkProximity = (ent) => {
            const ox = parseInt(ent.style.left); const oy = parseInt(ent.style.top);
            return Math.abs(boxX - ox) < 70 && Math.abs(boxY - oy) < 70;
        };

        let hitSomething = false;
        // Check obstacles (resources)
        for (const obs of obstacles) {
          if (checkProximity(obs)) { 
            const resourceType = obs.dataset.type;
            const resourceConfigEntry = resourceConfig[resourceType];
            const requiredToolName = resourceConfigEntry.toolNeeded;
            let canHarvest = true;
            let equippedLevel = 0; // Bare hands have a harvest level of 0

            // Determine equipped tool level
            if (player.equipped.pickaxe && resourceConfig[player.equipped.pickaxe]) {
                equippedLevel = resourceConfig[player.equipped.pickaxe].harvestLevel || 0;
            }

            if (requiredToolName) {
                // If a tool is required, get its level.
                const requiredLevel = resourceConfig[requiredToolName].harvestLevel || 99;

                // Compare levels
                if (equippedLevel < requiredLevel) {
                    canHarvest = false;
                    if (equippedLevel === 0) {
                        logMessage(`You need a ${requiredToolName} to mine ${resourceType}!`);
                    } else {
                        logMessage(`Your ${player.equipped.pickaxe} isn't strong enough!`);
                    }
                }
            }
            
            if (canHarvest) {
                let amt = parseInt(obs.dataset.amount);
                if (amt > 0) {
                  obs.dataset.amount = amt - 1;
                  collectResource(obs.dataset.type, 1);
                  hitSomething = true;
                  break; // Only hit one thing
                }
            }
          }
        }

if (player.equipped.pickaxe === 'shovel') {
  // Always collect dirt
  collectResource('dirt', 1);

  // 2% chance for wheat seed
  if (Math.random() < 0.02) {
    collectResource('wheat-seed', 1);
    logMessage("You found a wheat seed!");
  }
  hitSomething = true; // counts as an action
}

        if (!hitSomething) {
            // Check enemies (same as before)
            for (const enemy of enemies) {
                if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) continue;
                if (checkProximity(enemy)) {
                    let hp = parseInt(enemy.dataset.hp); hp -= punchDamage; enemy.dataset.hp = hp; enemy.textContent = `${enemy.dataset.type} (${hp})`;
                    if (hp <= 0) { gameArea.removeChild(enemy); const drops = enemyConfig[enemy.dataset.type].drops; for (const dropType in drops) collectResource(dropType, drops[dropType]); logMessage(`${enemy.dataset.type} defeated!`); }
                    else { logMessage(`Dealt ${punchDamage} damage to ${enemy.dataset.type}.`); }
                    break;
                }
            }
        }
      }
    });
    startDayNightCycle();
  </script>
</body>
</html>
