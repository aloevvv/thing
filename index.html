<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Procedural Room Game</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: darkgreen;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: sans-serif;
    }

    #gameArea {
      position: relative;
      width: 600px;
      height: 400px;
      border: 2px solid white;
      overflow: hidden;
      margin-bottom: 10px;
    }

    #box {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: white;
    }

    /* Obstacle styles */
    .tree, .rock, .gold, .diamond, .berrybush {
      position: absolute;
      width: 40px;
      height: 40px;
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 10px;
      color: black;
    }
    .tree { background-color: green; }
    .rock { background-color: gray; }
    .gold { background-color: gold; }
    .diamond { background-color: cyan; }
    .berrybush { background-color: darkred; border-radius: 50%; } /* Added berry bush style */

    /* UI Overlay */
    #uiContainer {
        display: flex;
        flex-direction: column;
        width: 600px;
    }

    /* Status Bars */
    .status-bar-container {
        width: 100%;
        height: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        border: 1px solid white;
        margin-bottom: 5px;
        position: relative;
    }

    .status-bar-fill {
        height: 100%;
        transition: width 0.3s ease-out;
    }

    .status-bar-label {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        text-align: center;
        line-height: 20px;
        font-size: 12px;
        text-shadow: 1px 1px 1px black;
    }

    #hp-fill { background-color: red; }
    #hunger-fill { background-color: orange; }

    /* Inventory */
    #inventory {
      display: grid;
      grid-template-columns: repeat(9, 60px);
      gap: 5px;
      width: 600px;
      height: 60px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border: 2px solid white;
    }

    .inv-slot {
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid white;
      position: relative;
      cursor: pointer; /* Make slots look clickable */
    }
    
    .inv-slot:hover {
        background-color: rgba(255, 255, 255, 0.3);
    }

    .item-icon {
        width: 80%;
        height: 80%;
        margin: 10% auto;
    }

    .item-count {
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 10px;
        color: white;
        text-shadow: 1px 1px 1px black;
    }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="box"></div>
  </div>

  <div id="uiContainer">
    <div class="status-bar-container">
        <div id="hp-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HP: <span id="hp-value">100</span>/100</div>
    </div>
    <div class="status-bar-container">
        <div id="hunger-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HUNGER: <span id="hunger-value">100</span></div>
    </div>
    <div id="inventory">
      <!-- 9 inventory slots will be generated by JS -->
    </div>
  </div>

  <script>
    const gameArea = document.getElementById("gameArea");
    const inventoryEl = document.getElementById("inventory");
    const hpFillEl = document.getElementById("hp-fill");
    const hpValueEl = document.getElementById("hp-value");
    const hungerFillEl = document.getElementById("hunger-fill");
    const hungerValueEl = document.getElementById("hunger-value");
    const step = 20;
    const INVENTORY_SIZE = 9;

    let boxX = 280;
    let boxY = 180;
    let roomX = 0;
    let roomY = 0;
    const rooms = {};

    const player = {
        hp: 100,
        maxHp: 100,
        hunger: 100,
        maxHunger: 100,
        inventory: {}
    };

    // --- Resource Definitions (Added berrybush) ---
    const resourceConfig = {
      tree: { max: 30, regen: 5000, color: 'green', type: 'material' },
      rock: { max: 20, regen: 10000, color: 'gray', type: 'material' },
      gold: { max: 10, regen: 20000, color: 'gold', type: 'material' },
      diamond: { max: 10, regen: 20000, color: 'cyan', type: 'material' },
      berrybush: { max: 6, regen: 8000, color: 'darkred', type: 'food', foodValue: 10 } // Berries regen every 8 seconds
    };

    // --- UI Update Functions ---
    function updateHPUI() {
        hpValueEl.textContent = player.hp;
        const percent = (player.hp / player.maxHp) * 100;
        hpFillEl.style.width = percent + "%";
        if (player.hp <= 0) alert("You died!");
    }

    function updateHungerUI() {
        hungerValueEl.textContent = player.hunger;
        const percent = (player.hunger / player.maxHunger) * 100;
        hungerFillEl.style.width = percent + "%";
    }

    function updateInventoryUI() {
        inventoryEl.innerHTML = '';
        const items = Object.entries(player.inventory);
        for (let i = 0; i < INVENTORY_SIZE; i++) {
            const slot = document.createElement("div");
            slot.className = "inv-slot";
            // Store the index for click handling later
            slot.dataset.index = i;

            if (i < items.length) {
                const [type, count] = items[i];
                if (count > 0) {
                    const icon = document.createElement("div");
                    icon.className = `item-icon ${type}`;
                    icon.style.backgroundColor = resourceConfig[type].color; // Use color for icon
                    slot.appendChild(icon);
                    
                    const countSpan = document.createElement("span");
                    countSpan.className = "item-count";
                    countSpan.textContent = count;
                    slot.appendChild(countSpan);
                    // Store the type for click handling
                    slot.dataset.type = type;
                }
            }
            inventoryEl.appendChild(slot);
        }
    }

    // --- Interaction Logic ---

    // Eating Mechanic
    function eatItem(itemType) {
        const config = resourceConfig[itemType];
        if (config && config.type === 'food' && player.inventory[itemType] > 0) {
            player.inventory[itemType]--;
            player.hunger += config.foodValue;
            if (player.hunger > player.maxHunger) player.hunger = player.maxHunger;
            
            // Remove item from inventory object if count reaches zero
            if (player.inventory[itemType] <= 0) {
                delete player.inventory[itemType];
            }

            updateHungerUI();
            updateInventoryUI();
            console.log(`Ate 1 ${itemType}. Hunger is now ${player.hunger}`);
        } else if (config.type === 'material') {
            console.log(`Can't eat ${itemType}! It's just a material.`);
        }
    }

    // Add click listener to the *parent* inventory container (Event Delegation)
    inventoryEl.addEventListener('click', (event) => {
        // Find the slot element that was clicked, or is a parent of what was clicked
        const clickedSlot = event.target.closest('.inv-slot');
        if (clickedSlot && clickedSlot.dataset.type) {
            eatItem(clickedSlot.dataset.type);
        }
    });


    // --- Game World Generation/Persistence ---

    function collectResource(type, amount) {
        if (player.inventory[type]) {
            player.inventory[type] += amount;
        } else {
            player.inventory[type] = amount;
        }
        updateInventoryUI();
    }

    function place(type, count, obstacles) {
      const cfg = resourceConfig[type];

      for (let i = 0; i < count; i++) {
        const obs = document.createElement("div");
        obs.className = type;
        obs.style.left = Math.floor(Math.random() * (gameArea.offsetWidth - 40)) + "px";
        obs.style.top = Math.floor(Math.random() * (gameArea.offsetHeight - 40)) + "px";

        obs.dataset.type = type;
        obs.dataset.amount = cfg.max;
        obs.style.backgroundColor = cfg.color; // Ensure visual matches the type
        
        obstacles.push(obs);
      }
    }

    function generateRoom(rx, ry) {
      const key = `${rx},${ry}`;
      if (rooms[key]) return rooms[key];

      const roomData = { obstacles: [], intervals: [] };
      // Generate standard resources
      place("tree", Math.floor(Math.random() * 3) + 2, roomData.obstacles);
      place("rock", Math.floor(Math.random() * 2) + 1, roomData.obstacles);
      if (Math.random() < 0.25) place("gold", 1, roomData.obstacles);
      if (Math.random() < 0.05) place("diamond", 1, roomData.obstacles);
      // Generate berry bushes
      place("berrybush", Math.floor(Math.random() * 3) + 1, roomData.obstacles); // 1-3 bushes per room

      rooms[key] = roomData;
      return roomData;
    }
    
    // ... clearRoom, loadRoom, canMove functions are the same as before ...
    // (They use the updated resourceConfig reference)

    function clearRoom() {
      const key = `${roomX},${roomY}`;
      const currentRoomData = rooms[key];
      if (currentRoomData) {
          currentRoomData.obstacles.forEach(child => {
              if (child.parentNode === gameArea) gameArea.removeChild(child);
          });
          currentRoomData.intervals.forEach(clearInterval);
          currentRoomData.intervals = [];
      }
    }

    function loadRoom(rx, ry) {
      const roomData = generateRoom(rx, ry);
      roomData.obstacles.forEach(obs => {
        gameArea.appendChild(obs);
        const cfg = resourceConfig[obs.dataset.type];
        const intervalId = setInterval(() => {
          let amt = parseInt(obs.dataset.amount);
          if (amt < cfg.max) {
            obs.dataset.amount = amt + 1;
            // obs.textContent = obs.dataset.amount; // Optional: Show count on bush
          }
        }, cfg.regen);
        roomData.intervals.push(intervalId);
      });
    }

    function canMove(newX, newY) {
      const boxRect = {x:newX, y:newY, w:40, h:40};
      const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
      for (const obs of obstacles) {
        const rect = obs.getBoundingClientRect();
        const areaRect = gameArea.getBoundingClientRect();
        const ox = rect.left - areaRect.left;
        const oy = rect.top - areaRect.top;
        const ow = rect.width;
        const oh = rect.height;
        if (boxRect.x < ox + ow && boxRect.x + boxRect.w > ox && boxRect.y < oy + oh && boxRect.y + boxRect.h > oy) {
          return false;
        }
      }
      return true;
    }


    // --- Core Game Loops and Handlers ---

    // Initial setup
    loadRoom(roomX, roomY);
    // ... initial UI updates ...
    updateHPUI();
    updateHungerUI();
    updateInventoryUI();


    // Hunger depletion loop (45 seconds)
    setInterval(() => {
        if (player.hunger > 0) {
            player.hunger -= 10;
            if (player.hunger < 0) player.hunger = 0;
            updateHungerUI();
        }
    }, 45000);

    // Damage loop (3 seconds if starving)
    setInterval(() => {
        if (player.hunger === 0 && player.hp > 0) {
            player.hp -= 10;
            updateHPUI();
        }
    }, 3000);


    // Movement and Room Change Handler (Same as before)
    document.addEventListener("keydown", (event) => {
      let newX = boxX;
      let newY = boxY;
      let roomChanged = false;

      if (event.key === "ArrowUp") newY -= step;
      else if (event.key === "ArrowDown") newY += step;
      else if (event.key === "ArrowLeft") newX -= step;
      else if (event.key === "ArrowRight") newX += step;
      else if (event.code !== "Space") return;

      if (newX < 0) { clearRoom(); roomX--; newX = gameArea.offsetWidth - 40; roomChanged = true; }
      else if (newX > gameArea.offsetWidth - 40) { clearRoom(); roomX++; newX = 0; roomChanged = true; }
      else if (newY < 0) { clearRoom(); roomY--; newY = gameArea.offsetHeight - 40; roomChanged = true; }
      else if (newY > gameArea.offsetHeight - 40) { clearRoom(); roomY++; newY = 0; roomChanged = true; }

      if (roomChanged) loadRoom(roomX, roomY);

      if (canMove(newX, newY)) {
        boxX = newX;
        boxY = newY;
        box.style.left = boxX + "px";
        box.style.top = boxY + "px";
      }
    });
    
    // Punch Mechanic Handler (Now collects berries too)
    document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
        for (const obs of obstacles) {
          const rect = obs.getBoundingClientRect();
          const areaRect = gameArea.getBoundingClientRect();
          const ox = rect.left - areaRect.left;
          const oy = rect.top - areaRect.top;
          const ow = rect.width;
          const oh = rect.height;

          const dx = Math.abs(boxX - ox);
          const dy = Math.abs(boxY - oy);

          if (dx < 50 && dy < 50) { 
            let amt = parseInt(obs.dataset.amount);
            if (amt > 0) {
              obs.dataset.amount = amt - 1;
              collectResource(obs.dataset.type, 1); // Add to inventory
            }
          }
        }
      }
    });
  </script>
</body>
</html>
