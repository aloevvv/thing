<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Procedural Room Game</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: darkgreen;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: sans-serif;
    }

    #gameArea {
      position: relative;
      width: 600px;
      height: 400px;
      border: 2px solid white;
      overflow: hidden;
      margin-bottom: 10px;
    }

    #box {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: white;
      transition: left 0.1s linear, top 0.1s linear;
      z-index: 10;
    }

    /* Obstacle styles */
    .tree, .rock, .gold, .diamond, .berrybush {
      position: absolute;
      width: 40px;
      height: 40px;
      box-sizing: border-box;
    }
    .tree { background-color: green; }
    .rock { background-color: gray; }
    .gold { background-color: gold; }
    .diamond { background-color: cyan; }
    .berrybush { background-color: darkred; border-radius: 50%; }

    /* Enemy styles */
    .enemy {
      position: absolute;
      width: 40px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 10px;
      transition: left 0.4s linear, top 0.4s linear;
      z-index: 5;
      border: 2px solid red;
      box-sizing: border-box;
    }
    .wolf { background-color: brown; }
    .bear { background-color: black; }
    .fox { background-color: orange; }

    /* UI Overlay and Inventory styles remain the same */
    #uiContainer { display: flex; flex-direction: column; width: 600px; }
    .status-bar-container { width: 100%; height: 20px; background-color: rgba(0, 0, 0, 0.5); border: 1px solid white; margin-bottom: 5px; position: relative; }
    .status-bar-fill { height: 100%; transition: width 0.3s ease-out; }
    .status-bar-label { position: absolute; top: 0; left: 0; width: 100%; text-align: center; line-height: 20px; font-size: 12px; text-shadow: 1px 1px 1px black; }
    #hp-fill { background-color: red; }
    #hunger-fill { background-color: orange; }
    #inventory { display: grid; grid-template-columns: repeat(9, 60px); gap: 5px; width: 600px; height: 60px; background-color: rgba(0, 0, 0, 0.5); padding: 5px; border: 2px solid white; }
    .inv-slot { width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.1); border: 1px solid white; position: relative; cursor: pointer; }
    .inv-slot:hover { background-color: rgba(255, 255, 255, 0.3); }
    .item-icon { width: 80%; height: 80%; margin: 10% auto; }
    .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: white; text-shadow: 1px 1px 1px black; }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="box"></div>
  </div>

  <div id="uiContainer">
    <div class="status-bar-container">
        <div id="hp-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HP: <span id="hp-value">100</span>/100</div>
    </div>
    <div class="status-bar-container">
        <div id="hunger-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HUNGER: <span id="hunger-value">100</span></div>
    </div>
    <div id="inventory"></div>
  </div>

  <script>
    const gameArea = document.getElementById("gameArea");
    const box = document.getElementById("box");
    const inventoryEl = document.getElementById("inventory");
    const hpFillEl = document.getElementById("hp-fill");
    const hpValueEl = document.getElementById("hp-value");
    const hungerFillEl = document.getElementById("hunger-fill");
    const hungerValueEl = document.getElementById("hunger-value");
    const step = 20;
    const INVENTORY_SIZE = 9;
    const GRID_SIZE = 40;

    let boxX = 280;
    let boxY = 180;
    let roomX = 0;
    let roomY = 0;
    const rooms = {};
    let lastHitTime = 0;

    const player = {
        hp: 100,
        maxHp: 100,
        hunger: 100,
        maxHunger: 100,
        inventory: {}
    };

    const resourceConfig = {
      tree: { max: 30, regen: 5000, color: 'green', type: 'material' },
      rock: { max: 20, regen: 10000, color: 'gray', type: 'material' },
      gold: { max: 10, regen: 20000, color: 'gold', type: 'material' },
      diamond: { max: 10, regen: 20000, color: 'cyan', type: 'material' },
      berrybush: { max: 6, regen: 8000, color: 'darkred', type: 'food', foodValue: 10 }
    };

    const enemyConfig = {
        wolf: { hp: 200, damage: 10, speed: 10, range: 200, drops: { meat: 1 }, spawnChance: 0.10 },
        bear: { hp: 350, damage: 20, speed: 5, range: 200, drops: { meat: 2, fur: 1 }, spawnChance: 0.10 },
        fox: { hp: 200, damage: 10, speed: 15, range: 200, drops: { meat: 1 }, spawnChance: 0.10 }
    };
    resourceConfig['meat'] = { color: 'pink', type: 'food', foodValue: 20 };
    resourceConfig['fur'] = { color: 'white', type: 'material' };

    // --- UI Update Functions ---
    function updateHPUI() {
        hpValueEl.textContent = player.hp;
        const percent = (player.hp / player.maxHp) * 100;
        hpFillEl.style.width = percent + "%";
        if (player.hp <= 0) alert("You died!");
    }
    function updateHungerUI() {
        hungerValueEl.textContent = player.hunger;
        const percent = (player.hunger / player.maxHunger) * 100;
        hungerFillEl.style.width = percent + "%";
    }
    function updateInventoryUI() {
        inventoryEl.innerHTML = '';
        const items = Object.entries(player.inventory);
        for (let i = 0; i < INVENTORY_SIZE; i++) {
            const slot = document.createElement("div");
            slot.className = "inv-slot";
            slot.dataset.index = i;
            if (i < items.length) {
                const [type, count] = items[i];
                if (count > 0) {
                    const icon = document.createElement("div");
                    icon.className = `item-icon ${type}`;
                    icon.style.backgroundColor = resourceConfig[type].color;
                    slot.appendChild(icon);
                    const countSpan = document.createElement("span");
                    countSpan.className = "item-count";
                    countSpan.textContent = count;
                    slot.appendChild(countSpan);
                    slot.dataset.type = type;
                }
            }
            inventoryEl.appendChild(slot);
        }
    }

    // --- Interaction Logic ---
    function eatItem(itemType) {
        const config = resourceConfig[itemType];
        if (config && config.type === 'food' && player.inventory[itemType] > 0) {
            player.inventory[itemType]--;
            player.hunger += config.foodValue;
            if (player.hunger > player.maxHunger) player.hunger = player.maxHunger;
            if (player.inventory[itemType] <= 0) delete player.inventory[itemType];
            updateHungerUI();
            updateInventoryUI();
        }
    }
    inventoryEl.addEventListener('click', (event) => {
        const clickedSlot = event.target.closest('.inv-slot');
        if (clickedSlot && clickedSlot.dataset.type) {
            eatItem(clickedSlot.dataset.type);
        }
    });
    function collectResource(type, amount) {
        if (player.inventory[type]) player.inventory[type] += amount;
        else player.inventory[type] = amount;
        updateInventoryUI();
    }
    function damagePlayer(amount) {
        player.hp -= amount;
        lastHitTime = Date.now(); // IMPORTANT: resets hit timer
        updateHPUI();
    }

    // --- Game World Generation/Persistence ---
    function placeObstacle(type, count, obstacles) {
      const cfg = resourceConfig[type];
      for (let i = 0; i < count; i++) {
        const obs = document.createElement("div");
        obs.className = type;
        obs.style.left = Math.floor(Math.random() * (gameArea.offsetWidth - GRID_SIZE)) + "px";
        obs.style.top = Math.floor(Math.random() * (gameArea.offsetHeight - GRID_SIZE)) + "px";
        obs.dataset.type = type;
        obs.dataset.amount = cfg.max;
        obs.style.backgroundColor = cfg.color;
        obstacles.push(obs);
      }
    }

    function createEnemy(type, x, y) {
        const config = enemyConfig[type];
        const enemyEl = document.createElement("div");
        enemyEl.className = `enemy ${type}`;
        enemyEl.style.left = x + "px";
        enemyEl.style.top = y + "px";
        enemyEl.dataset.type = type;
        enemyEl.dataset.hp = config.hp;
        enemyEl.dataset.maxHp = config.hp;
        enemyEl.textContent = `${type} (${config.hp})`;
        return enemyEl;
    }

    function placeEnemies(enemies) {
        if (Math.random() < enemyConfig.wolf.spawnChance) enemies.push(createEnemy('wolf', Math.random() * (gameArea.offsetWidth - GRID_SIZE), Math.random() * (gameArea.offsetHeight - GRID_SIZE)));
        if (Math.random() < enemyConfig.bear.spawnChance) enemies.push(createEnemy('bear', Math.random() * (gameArea.offsetWidth - GRID_SIZE), Math.random() * (gameArea.offsetHeight - GRID_SIZE)));
        if (Math.random() < enemyConfig.fox.spawnChance) enemies.push(createEnemy('fox', Math.random() * (gameArea.offsetWidth - GRID_SIZE), Math.random() * (gameArea.offsetHeight - GRID_SIZE)));
    }
    
    function generateRoom(rx, ry) {
      const key = `${rx},${ry}`;
      if (rooms[key]) return rooms[key];
      const roomData = { obstacles: [], enemies: [], intervals: [] };
      placeObstacle("tree", Math.floor(Math.random() * 3) + 2, roomData.obstacles);
      placeObstacle("rock", Math.floor(Math.random() * 2) + 1, roomData.obstacles);
      if (Math.random() < 0.25) placeObstacle("gold", 1, roomData.obstacles);
      if (Math.random() < 0.05) placeObstacle("diamond", 1, roomData.obstacles);
      placeObstacle("berrybush", Math.floor(Math.random() * 3) + 1, roomData.obstacles);
      placeEnemies(roomData.enemies);
      rooms[key] = roomData;
      return roomData;
    }
    // ... clearRoom and loadRoom functions remain the same as previous response ...
    function clearRoom() {
      const key = `${roomX},${roomY}`;
      const currentRoomData = rooms[key];
      if (currentRoomData) {
          currentRoomData.obstacles.forEach(child => { if (child.parentNode === gameArea) gameArea.removeChild(child); });
          currentRoomData.enemies.forEach(child => { if (child.parentNode === gameArea) gameArea.removeChild(child); });
          currentRoomData.intervals.forEach(clearInterval);
          currentRoomData.intervals = [];
      }
    }
    function loadRoom(rx, ry) {
      const roomData = generateRoom(rx, ry);
      roomData.obstacles.forEach(obs => {
        gameArea.appendChild(obs);
        const cfg = resourceConfig[obs.dataset.type];
        const intervalId = setInterval(() => {
          let amt = parseInt(obs.dataset.amount);
          if (amt < cfg.max) obs.dataset.amount = amt + 1;
        }, cfg.regen);
        roomData.intervals.push(intervalId);
      });
      roomData.enemies.forEach(enemy => {
          if (enemy.dataset.hp > 0) { gameArea.appendChild(enemy); }
      });
    }

    // Collision check function (ONLY for solid obstacles/walls)
    function checkObstacleCollision(x, y, obstacles) {
        const rect1 = {x, y, w: GRID_SIZE, h: GRID_SIZE};
        for (const item of obstacles) {
            if (item.parentNode === gameArea) {
                const ox = parseInt(item.style.left);
                const oy = parseInt(item.style.top);
                const rect2 = {x: ox, y: oy, w: GRID_SIZE, h: GRID_SIZE};

                if (rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x &&
                    rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y) {
                    return true;
                }
            }
        }
        return false;
    }

    function canMovePlayer(newX, newY) {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        // Player only checks collision against obstacles, not enemies
        return !checkObstacleCollision(newX, newY, currentRoomData.obstacles);
    }
    
    // --- Core Game Loops and Handlers ---

    // Initial setup
    loadRoom(roomX, roomY);
    updateHPUI();
    updateHungerUI();
    updateInventoryUI();

    // Hunger depletion loop (45 seconds) and Damage/Regen loop (3 seconds)
    setInterval(() => {
        if (player.hunger > 0) {
            player.hunger -= 10;
            if (player.hunger < 0) player.hunger = 0;
            updateHungerUI();
        }
    }, 45000);

    setInterval(() => {
        if (player.hunger === 0 && player.hp > 0) {
            damagePlayer(10);
        }
        
        // Healing logic: 5 HP every 3 seconds if not hit for 5s AND hunger > 70%
        if (Date.now() - lastHitTime >= 5000 && player.hunger > player.maxHunger * 0.70 && player.hp < player.maxHp) {
            player.hp += 5;
            if (player.hp > player.maxHp) player.hp = player.maxHp;
            updateHPUI();
        }
    }, 3000);


    // AI Update Loop (~0.5 seconds) - Enemies now phase through each other and player
    setInterval(() => {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        if (!currentRoomData) return;

        currentRoomData.enemies.forEach(enemy => {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) return;

            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);
            const dx = boxX - eX;
            const dy = boxY - eY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const config = enemyConfig[enemy.dataset.type];

            // Use larger range for detection
            if (distance < config.range) { 
                let moveX = 0;
                let moveY = 0;
                const enemyStep = config.speed;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = Math.sign(dx) * enemyStep;
                } else {
                    moveY = Math.sign(dy) * enemyStep;
                }
                
                let newEX = eX + moveX;
                let newEY = eY + moveY;

                // Check collision only against *obstacles* (walls), not other entities
                if (!checkObstacleCollision(newEX, newEY, currentRoomData.obstacles)) {
                    // Boundary check
                    if (newEX >= 0 && newEX <= gameArea.offsetWidth - GRID_SIZE &&
                        newEY >= 0 && newEY <= gameArea.offsetHeight - GRID_SIZE) {
                            enemy.style.left = newEX + "px";
                            enemy.style.top = newEY + "px";
                    }
                }
            }
        });
    }, 500);

    // Enemy Attack loop (Every 3 seconds, calls damagePlayer)
    setInterval(() => {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        if (!currentRoomData || player.hp <= 0) return;

        currentRoomData.enemies.forEach(enemy => {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) return;

            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);
            const config = enemyConfig[enemy.dataset.type];

            // Check adjacency for attack
            const dx = Math.abs(boxX - eX);
            const dy = Math.abs(boxY - eY);
            if (dx < GRID_SIZE && dy < GRID_SIZE) { 
                damagePlayer(config.damage);
            }
        });
    }, 3000);


    // Movement Handler
    document.addEventListener("keydown", (event) => {
      let newX = boxX;
      let newY = boxY;
      let roomChanged = false;

      if (event.key === "ArrowUp") newY -= step;
      else if (event.key === "ArrowDown") newY += step;
      else if (event.key === "ArrowLeft") newX -= step;
      else if (event.key === "ArrowRight") newX += step;
      else if (event.code !== "Space") return;

      if (newX < 0) { clearRoom(); roomX--; newX = gameArea.offsetWidth - 40; roomChanged = true; }
      else if (newX > gameArea.offsetWidth - 40) { clearRoom(); roomX++; newX = 0; roomChanged = true; }
      else if (newY < 0) { clearRoom(); roomY--; newY = gameArea.offsetHeight - 40; roomChanged = true; }
      else if (newY > gameArea.offsetHeight - 40) { clearRoom(); roomY++; newY = 0; roomChanged = true; }

      if (roomChanged) loadRoom(roomX, roomY);

      if (canMovePlayer(newX, newY)) {
        boxX = newX;
        boxY = newY;
        box.style.left = boxX + "px";
        box.style.top = boxY + "px";
      }
    });
    
    // Punch Mechanic Handler (same as before)
    document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
        const enemies = rooms[`${roomX},${roomY}`].enemies || [];
        const punchDamage = 10;

        for (const obs of obstacles) {
          const ox = parseInt(obs.style.left);
          const oy = parseInt(obs.style.top);
          if (Math.abs(boxX - ox) < 50 && Math.abs(boxY - oy) < 50) { 
            let amt = parseInt(obs.dataset.amount);
            if (amt > 0) {
              obs.dataset.amount = amt - 1;
              collectResource(obs.dataset.type, 1);
              break;
            }
          }
        }
        
        for (const enemy of enemies) {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) continue;
            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);

            if (Math.abs(boxX - eX) < 50 && Math.abs(boxY - eY) < 50) {
                let hp = parseInt(enemy.dataset.hp);
                hp -= punchDamage;
                enemy.dataset.hp = hp;
                enemy.textContent = `${enemy.dataset.type} (${hp})`;
                if (hp <= 0) {
                    gameArea.removeChild(enemy);
                    const drops = enemyConfig[enemy.dataset.type].drops;
                    for (const dropType in drops) {
                        collectResource(dropType, drops[dropType]);
                    }
                }
                break;
            }
        }
      }
    });
  </script>
</body>
</html>
