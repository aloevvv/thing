<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Procedural Room Game</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: darkgreen;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #gameArea {
      position: relative;
      width: 600px;
      height: 400px;
      border: 2px solid white;
      overflow: hidden;
    }

    #box {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: white;
    }

    /* Styles for obstacles remain the same */
    .tree {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: green;
    }

    .rock {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: gray;
    }

    .gold {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: gold;
    }

    .diamond {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: cyan;
    }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="box"></div>
  </div>

  <script>
    const gameArea = document.getElementById("gameArea");
    const box = document.getElementById("box");
    const step = 20;

    // Player position
    let boxX = 280;
    let boxY = 180;

    // Current room coordinates
    let roomX = 0;
    let roomY = 0;

    // Store rooms permanently (stores obstacles AND intervals)
    const rooms = {};

    // Resource definitions
    const resourceConfig = {
      tree: { max: 30, regen: 5000 },     // 1 every 5 sec
      rock: { max: 20, regen: 10000 },    // 1 every 10 sec
      gold: { max: 10, regen: 20000 },    // 1 every 20 sec
      diamond: { max: 10, regen: 20000 }  // 1 every 20 sec
    };

    // Helper to place and configure obstacles
    function place(type, count, obstacles) {
      const cfg = resourceConfig[type];

      for (let i = 0; i < count; i++) {
        const obs = document.createElement("div");
        obs.className = type;
        obs.style.left = Math.floor(Math.random() * (gameArea.offsetWidth - 40)) + "px";
        obs.style.top = Math.floor(Math.random() * (gameArea.offsetHeight - 40)) + "px";

        // Resource tracking data attributes
        obs.dataset.type = type;
        obs.dataset.amount = cfg.max;
        
        obstacles.push(obs);
      }
    }

    // Generate a room with obstacles (only runs the first time a room key is accessed)
    function generateRoom(rx, ry) {
      const key = `${rx},${ry}`;
      if (rooms[key]) return rooms[key]; // Already generated

      const roomData = {
          obstacles: [],
          intervals: [] // We will store interval IDs here
      };

      // Use the new place function to populate obstacles array
      place("tree", Math.floor(Math.random() * 3) + 2, roomData.obstacles);
      place("rock", Math.floor(Math.random() * 2) + 1, roomData.obstacles);
      if (Math.random() < 0.25) place("gold", 1, roomData.obstacles);
      if (Math.random() < 0.05) place("diamond", 1, roomData.obstacles);

      rooms[key] = roomData;
      return roomData;
    }

    // Clear current obstacles and stop their regen intervals
    function clearRoom() {
      const key = `${roomX},${roomY}`;
      const currentRoomData = rooms[key];

      if (currentRoomData) {
          // 1. Remove obstacles from the DOM
          currentRoomData.obstacles.forEach(child => {
              if (child.parentNode === gameArea) {
                  gameArea.removeChild(child);
              }
          });
          // 2. Stop all regeneration intervals for this room
          currentRoomData.intervals.forEach(clearInterval);
          currentRoomData.intervals = []; // Clear the list
      }
    }

    // Load room and start its regen intervals
    function loadRoom(rx, ry) {
      const roomData = generateRoom(rx, ry); // Get existing or newly created room data

      // 1. Append all obstacles for the new room into the gameArea
      roomData.obstacles.forEach(obs => {
        gameArea.appendChild(obs);

        // 2. Start regen intervals for visible items and store the interval ID
        const cfg = resourceConfig[obs.dataset.type];
        const intervalId = setInterval(() => {
          let amt = parseInt(obs.dataset.amount);
          if (amt < cfg.max) {
            obs.dataset.amount = amt + 1;
            // Optional: visual feedback when regening can be added here
          }
        }, cfg.regen);
        roomData.intervals.push(intervalId);
      });
    }

    // Collision detection (updated to use the new room data structure)
    function canMove(newX, newY) {
      const boxRect = {x:newX, y:newY, w:40, h:40};
      // Access obstacles via the room data object
      const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];

      for (const obs of obstacles) {
        // Use getBoundingClientRect() is fine, but needs to be recalculated relative to the game area origin
        const rect = obs.getBoundingClientRect();
        const areaRect = gameArea.getBoundingClientRect();
        const ox = rect.left - areaRect.left;
        const oy = rect.top - areaRect.top;
        const ow = rect.width;
        const oh = rect.height;
        if (boxRect.x < ox + ow &&
            boxRect.x + boxRect.w > ox &&
            boxRect.y < oy + oh &&
            boxRect.y + boxRect.h > oy) {
          return false;
        }
      }
      return true;
    }

    // Initial room setup
    loadRoom(roomX, roomY); // This loads the first room's elements onto the screen
    box.style.left = boxX + "px";
    box.style.top = boxY + "px";

    // Player Movement Handler
    document.addEventListener("keydown", (event) => {
      let newX = boxX;
      let newY = boxY;
      let roomChanged = false;

      if (event.key === "ArrowUp") newY -= step;
      else if (event.key === "ArrowDown") newY += step;
      else if (event.key === "ArrowLeft") newX -= step;
      else if (event.key === "ArrowRight") newX += step;
      // If none of the arrow keys were pressed, we don't proceed with movement/room change logic
      else if (event.code !== "Space") return;


      // Check if off screen
      if (newX < 0) {
          clearRoom(); // Clear previous room before updating coordinates
          roomX--;
          newX = gameArea.offsetWidth - 40;
          roomChanged = true;
      }
      else if (newX > gameArea.offsetWidth - 40) {
          clearRoom();
          roomX++;
          newX = 0;
          roomChanged = true;
      }
      else if (newY < 0) {
          clearRoom();
          roomY--;
          newY = gameArea.offsetHeight - 40;
          roomChanged = true;
      }
      else if (newY > gameArea.offsetHeight - 40) {
          clearRoom();
          roomY++;
          newY = 0;
          roomChanged = true;
      }

      if (roomChanged) {
          loadRoom(roomX, roomY); // Load the NEW room's elements onto the screen
      }

      // Collision check happens in the context of the *current* room coordinates
      if (canMove(newX, newY)) {
        boxX = newX;
        boxY = newY;
        box.style.left = boxX + "px";
        box.style.top = boxY + "px";
      }
    });
    
    // Punch Mechanic Handler (Separate listener for 'Space' prevents movement logic interference)
    document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        // Access obstacles via the room data object
        const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
        for (const obs of obstacles) {
          const rect = obs.getBoundingClientRect();
          const areaRect = gameArea.getBoundingClientRect();
          const ox = rect.left - areaRect.left;
          const oy = rect.top - areaRect.top;
          const ow = rect.width;
          const oh = rect.height;

          // Check proximity (within 50px)
          const dx = Math.abs(boxX - ox);
          const dy = Math.abs(boxY - oy);
          // 40 is the obstacle/player size
          if (dx < 50 && dy < 50) { 
            let amt = parseInt(obs.dataset.amount);
            if (amt > 0) {
              obs.dataset.amount = amt - 1;
              console.log(`Collected 1 ${obs.dataset.type}. Remaining: ${obs.dataset.amount}`);
              // Optional: visual feedback when harvesting (e.g., flash the obstacle red)
            } else {
              console.log(`${obs.dataset.type} is depleted!`);
            }
          }
        }
      }
    });
  </script>
</body>
</html>
