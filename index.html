<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Procedural Room Game</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: darkgreen;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: sans-serif;
    }

    #gameArea {
      position: relative;
      width: 600px;
      height: 400px;
      border: 2px solid white;
      overflow: hidden;
      margin-bottom: 10px; /* Space between game and UI */
    }

    #box {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: white;
    }

    /* Obstacle styles */
    .tree, .rock, .gold, .diamond {
      position: absolute;
      width: 40px;
      height: 40px;
      box-sizing: border-box; /* Ensures border/padding is inside width/height */
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 10px;
      color: black;
    }
    .tree { background-color: green; }
    .rock { background-color: gray; }
    .gold { background-color: gold; }
    .diamond { background-color: cyan; }

    /* UI Overlay */
    #uiContainer {
        display: flex;
        flex-direction: column;
        width: 600px;
    }

    /* Status Bars */
    .status-bar-container {
        width: 100%;
        height: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        border: 1px solid white;
        margin-bottom: 5px;
        position: relative;
    }

    .status-bar-fill {
        height: 100%;
        transition: width 0.3s ease-out;
    }

    .status-bar-label {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        text-align: center;
        line-height: 20px;
        font-size: 12px;
        text-shadow: 1px 1px 1px black;
    }

    #hp-fill { background-color: red; }
    #hunger-fill { background-color: orange; }

    /* Inventory */
    #inventory {
      display: grid;
      grid-template-columns: repeat(9, 60px);
      gap: 5px;
      width: 600px;
      height: 60px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border: 2px solid white;
    }

    .inv-slot {
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid white;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }

    .item-icon {
        width: 80%;
        height: 80%;
    }

    .item-count {
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 10px;
        color: white;
        text-shadow: 1px 1px 1px black;
    }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="box"></div>
  </div>

  <div id="uiContainer">
    <div class="status-bar-container">
        <div id="hp-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HP: <span id="hp-value">100</span>/100</div>
    </div>
    <div class="status-bar-container">
        <div id="hunger-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HUNGER: <span id="hunger-value">100</span></div>
    </div>
    <div id="inventory">
      <!-- 9 inventory slots will be generated by JS -->
    </div>
  </div>

  <script>
    const gameArea = document.getElementById("gameArea");
    const box = document.getElementById("box");
    const inventoryEl = document.getElementById("inventory");
    const hpFillEl = document.getElementById("hp-fill");
    const hpValueEl = document.getElementById("hp-value");
    const hungerFillEl = document.getElementById("hunger-fill");
    const hungerValueEl = document.getElementById("hunger-value");
    const step = 20;
    const INVENTORY_SIZE = 9;

    // Player State
    let boxX = 280;
    let boxY = 180;
    let roomX = 0;
    let roomY = 0;
    const rooms = {};

    // Player Stats
    const player = {
        hp: 100,
        maxHp: 100,
        hunger: 100,
        maxHunger: 100,
        inventory: {} // {type: count, ...}
    };

    // --- UI Update Functions ---
    function updateHPUI() {
        hpValueEl.textContent = player.hp;
        const percent = (player.hp / player.maxHp) * 100;
        hpFillEl.style.width = percent + "%";
        if (player.hp <= 0) {
            alert("You died!");
            // Add game over logic here
        }
    }

    function updateHungerUI() {
        hungerValueEl.textContent = player.hunger;
        const percent = (player.hunger / player.maxHunger) * 100;
        hungerFillEl.style.width = percent + "%";
    }

    function updateInventoryUI() {
        inventoryEl.innerHTML = ''; // Clear existing slots
        for (let i = 0; i < INVENTORY_SIZE; i++) {
            const slot = document.createElement("div");
            slot.className = "inv-slot";

            // Find an item that belongs in this conceptual slot index
            // A simple object map isn't indexed easily, so we iterate
            const items = Object.entries(player.inventory);
            if (i < items.length) {
                const [type, count] = items[i];
                if (count > 0) {
                    const icon = document.createElement("div");
                    icon.className = `item-icon ${type}`;
                    slot.appendChild(icon);
                    
                    const countSpan = document.createElement("span");
                    countSpan.className = "item-count";
                    countSpan.textContent = count;
                    slot.appendChild(countSpan);
                }
            }
            inventoryEl.appendChild(slot);
        }
    }

    // --- Resource Management ---
    const resourceConfig = {
      tree: { max: 30, regen: 5000, color: 'green' },
      rock: { max: 20, regen: 10000, color: 'gray' },
      gold: { max: 10, regen: 20000, color: 'gold' },
      diamond: { max: 10, regen: 20000, color: 'cyan' }
    };

    function collectResource(type, amount) {
        if (player.inventory[type]) {
            player.inventory[type] += amount;
        } else {
            player.inventory[type] = amount;
        }
        updateInventoryUI();
    }

    function place(type, count, obstacles) {
      for (let i = 0; i < count; i++) {
        const obs = document.createElement("div");
        obs.className = type;
        obs.style.left = Math.floor(Math.random() * (gameArea.offsetWidth - 40)) + "px";
        obs.style.top = Math.floor(Math.random() * (gameArea.offsetHeight - 40)) + "px";

        obs.dataset.type = type;
        obs.dataset.amount = resourceConfig[type].max;
        
        obstacles.push(obs);
      }
    }

    function generateRoom(rx, ry) {
      const key = `${rx},${ry}`;
      if (rooms[key]) return rooms[key];

      const roomData = { obstacles: [], intervals: [] };
      place("tree", Math.floor(Math.random() * 3) + 2, roomData.obstacles);
      place("rock", Math.floor(Math.random() * 2) + 1, roomData.obstacles);
      if (Math.random() < 0.25) place("gold", 1, roomData.obstacles);
      if (Math.random() < 0.05) place("diamond", 1, roomData.obstacles);

      rooms[key] = roomData;
      return roomData;
    }

    function clearRoom() {
      const key = `${roomX},${roomY}`;
      const currentRoomData = rooms[key];

      if (currentRoomData) {
          currentRoomData.obstacles.forEach(child => {
              if (child.parentNode === gameArea) gameArea.removeChild(child);
          });
          currentRoomData.intervals.forEach(clearInterval);
          currentRoomData.intervals = [];
      }
    }

    function loadRoom(rx, ry) {
      const roomData = generateRoom(rx, ry);

      roomData.obstacles.forEach(obs => {
        gameArea.appendChild(obs);

        const cfg = resourceConfig[obs.dataset.type];
        const intervalId = setInterval(() => {
          let amt = parseInt(obs.dataset.amount);
          if (amt < cfg.max) {
            obs.dataset.amount = amt + 1;
          }
        }, cfg.regen);
        roomData.intervals.push(intervalId);
      });
    }

    function canMove(newX, newY) {
      const boxRect = {x:newX, y:newY, w:40, h:40};
      const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
      for (const obs of obstacles) {
        const rect = obs.getBoundingClientRect();
        const areaRect = gameArea.getBoundingClientRect();
        const ox = rect.left - areaRect.left;
        const oy = rect.top - areaRect.top;
        const ow = rect.width;
        const oh = rect.height;
        if (boxRect.x < ox + ow &&
            boxRect.x + boxRect.w > ox &&
            boxRect.y < oy + oh &&
            boxRect.y + boxRect.h > oy) {
          return false;
        }
      }
      return true;
    }

    // --- Core Game Loops and Handlers ---

    // Initial setup
    loadRoom(roomX, roomY);
    box.style.left = boxX + "px";
    box.style.top = boxY + "px";
    updateHPUI();
    updateHungerUI();
    updateInventoryUI();


    // Hunger/HP loop (Main survival mechanics)
    // Hunger depletes every 45 seconds
    setInterval(() => {
        if (player.hunger > 0) {
            player.hunger -= 10; // Deplete hunger value
            if (player.hunger < 0) player.hunger = 0;
            updateHungerUI();
        }
    }, 45000); // 45 seconds

    // Damage loop (deals damage every 3 seconds if starving)
    setInterval(() => {
        if (player.hunger === 0) {
            player.hp -= 10; // Lose 10 HP
            updateHPUI();
        }
    }, 3000); // 3 seconds per tick


    // Movement and Room Change Handler
    document.addEventListener("keydown", (event) => {
      let newX = boxX;
      let newY = boxY;
      let roomChanged = false;

      if (event.key === "ArrowUp") newY -= step;
      else if (event.key === "ArrowDown") newY += step;
      else if (event.key === "ArrowLeft") newX -= step;
      else if (event.key === "ArrowRight") newX += step;
      else if (event.code !== "Space") return; // Only process arrow keys and space

      // Check if off screen
      if (newX < 0) { clearRoom(); roomX--; newX = gameArea.offsetWidth - 40; roomChanged = true; }
      else if (newX > gameArea.offsetWidth - 40) { clearRoom(); roomX++; newX = 0; roomChanged = true; }
      else if (newY < 0) { clearRoom(); roomY--; newY = gameArea.offsetHeight - 40; roomChanged = true; }
      else if (newY > gameArea.offsetHeight - 40) { clearRoom(); roomY++; newY = 0; roomChanged = true; }

      if (roomChanged) loadRoom(roomX, roomY);

      if (canMove(newX, newY)) {
        boxX = newX;
        boxY = newY;
        box.style.left = boxX + "px";
        box.style.top = boxY + "px";
      }
    });
    
    // Punch Mechanic Handler
    document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
        for (const obs of obstacles) {
          const rect = obs.getBoundingClientRect();
          const areaRect = gameArea.getBoundingClientRect();
          const ox = rect.left - areaRect.left;
          const oy = rect.top - areaRect.top;
          const ow = rect.width;
          const oh = rect.height;

          const dx = Math.abs(boxX - ox);
          const dy = Math.abs(boxY - oy);

          // Check proximity (within 50px)
          if (dx < 50 && dy < 50) { 
            let amt = parseInt(obs.dataset.amount);
            if (amt > 0) {
              obs.dataset.amount = amt - 1;
              collectResource(obs.dataset.type, 1); // Add to inventory
            }
          }
        }
      }
    });
  </script>
</body>
</html>
