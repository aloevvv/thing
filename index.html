<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Procedural Room Game</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: darkgreen;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #gameArea {
      position: relative;
      width: 600px;
      height: 400px;
      border: 2px solid white;
      overflow: hidden;
    }

    #box {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: white;
    }

    .tree {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: green;
    }

    .rock {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: gray;
    }

    .gold {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: gold;
    }

    .diamond {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: cyan;
    }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="box"></div>
  </div>

  <script>
      const gameArea = document.getElementById("gameArea");
    const box = document.getElementById("box");
    const step = 20;

    // Player position
    let boxX = 280;
    let boxY = 180;

    // Current room coordinates
    let roomX = 0;
    let roomY = 0;

    // Store rooms permanently
    const rooms = {};

    // Generate a room with obstacles (only runs the first time a room key is accessed)
    function generateRoom(rx, ry) {
      const key = `${rx},${ry}`;
      if (rooms[key]) {
        // If the room already exists in storage, return the stored list of DOM elements.
        return rooms[key];
      }

      const obstacles = [];

      // Helper to place obstacle
      function place(type, count) {
        for (let i = 0; i < count; i++) {
          const obs = document.createElement("div");
          obs.className = type;
          obs.style.left = Math.floor(Math.random() * (gameArea.offsetWidth - 40)) + "px";
          obs.style.top = Math.floor(Math.random() * (gameArea.offsetHeight - 40)) + "px";
          
          // CRITICAL FIX: We do NOT append here anymore. We only create and store.
          // The loadRoom function handles appending to the DOM.
          
          obstacles.push(obs);
        }
      }

      // Guaranteed trees (2–4)
      place("tree", Math.floor(Math.random() * 3) + 2);

      // Guaranteed rocks (1–2)
      place("rock", Math.floor(Math.random() * 2) + 1);

      // 25% chance gold
      if (Math.random() < 0.25) place("gold", 1);

      // 5% chance diamond
      if (Math.random() < 0.05) place("diamond", 1);

      rooms[key] = obstacles; // Store the *elements* in our map
      return obstacles;
    }

    // Clear current obstacles
    function clearRoom() {
      // Use a faster method to remove all current obstacles generated by the game logic
      const obstacles = rooms[`${roomX},${roomY}`] || [];
      obstacles.forEach(child => {
          // Check if the child is currently in the game area before trying to remove it
          if (child.parentNode === gameArea) {
              gameArea.removeChild(child);
          }
      });
    }

    // Load room
    function loadRoom(rx, ry) {
      // First, clear the obstacles from the *previous* room (before updating roomX/roomY)
      // NOTE: I moved the clearRoom call to the movement logic just before changing room coords,
      // but the central issue is how we load the *new* room's contents.

      // We call generateRoom, which either creates new obstacles or returns the stored ones.
      const currentRoomObstacles = generateRoom(rx, ry);

      // CRITICAL FIX: Append all obstacles for the new room into the gameArea
      currentRoomObstacles.forEach(obs => {
        gameArea.appendChild(obs);
      });
    }

    // Collision detection
    function canMove(newX, newY) {
      const boxRect = {x:newX, y:newY, w:40, h:40};
      // The rooms object stores the actual DOM elements, which we can iterate over
      const obstacles = rooms[`${roomX},${roomY}`] || [];
      for (const obs of obstacles) {
        // Use getBoundingClientRect() is fine, but needs to be recalculated relative to the game area origin
        const rect = obs.getBoundingClientRect();
        const areaRect = gameArea.getBoundingClientRect();
        const ox = rect.left - areaRect.left;
        const oy = rect.top - areaRect.top;
        const ow = rect.width;
        const oh = rect.height;
        if (boxRect.x < ox + ow &&
            boxRect.x + boxRect.w > ox &&
            boxRect.y < oy + oh &&
            boxRect.y + boxRect.h > oy) {
          return false;
        }
      }
      return true;
    }

    // Initial room setup
    loadRoom(roomX, roomY); // This loads the first room's elements onto the screen
    box.style.left = boxX + "px";
    box.style.top = boxY + "px";

    document.addEventListener("keydown", (event) => {
      let newX = boxX;
      let newY = boxY;
      let roomChanged = false;

      if (event.key === "ArrowUp") newY -= step;
      if (event.key === "ArrowDown") newY += step;
      if (event.key === "ArrowLeft") newX -= step;
      if (event.key === "ArrowRight") newX += step;

      // Check if off screen
      if (newX < 0) {
          clearRoom(); // Clear previous room before updating coordinates
          roomX--;
          newX = gameArea.offsetWidth - 40;
          roomChanged = true;
      }
      else if (newX > gameArea.offsetWidth - 40) {
          clearRoom();
          roomX++;
          newX = 0;
          roomChanged = true;
      }
      else if (newY < 0) {
          clearRoom();
          roomY--;
          newY = gameArea.offsetHeight - 40;
          roomChanged = true;
      }
      else if (newY > gameArea.offsetHeight - 40) {
          clearRoom();
          roomY++;
          newY = 0;
          roomChanged = true;
      }

      if (roomChanged) {
          loadRoom(roomX, roomY); // Load the NEW room's elements onto the screen
      }

      // Collision check happens in the context of the *current* room coordinates
      if (canMove(newX, newY)) {
        boxX = newX;
        boxY = newY;
        box.style.left = boxX + "px";
        box.style.top = boxY + "px";
      }
    });
</script>
</body>
</html>
