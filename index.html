<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Procedural Room Game</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background-color: darkgreen;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: sans-serif;
    }

    #gameArea {
      position: relative;
      width: 600px;
      height: 400px;
      border: 2px solid white;
      overflow: hidden;
      margin-bottom: 10px;
    }

    #box {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: white;
      transition: left 0.1s linear, top 0.1s linear; /* Smooth player movement */
      z-index: 10;
    }

    /* Obstacle styles */
    .tree, .rock, .gold, .diamond, .berrybush {
      position: absolute;
      width: 40px;
      height: 40px;
      box-sizing: border-box;
    }
    .tree { background-color: green; }
    .rock { background-color: gray; }
    .gold { background-color: gold; }
    .diamond { background-color: cyan; }
    .berrybush { background-color: darkred; border-radius: 50%; }

    /* Enemy styles */
    .enemy {
      position: absolute;
      width: 40px;
      height: 40px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 10px;
      transition: left 0.4s linear, top 0.4s linear; /* Slower enemy movement transition */
    }
    .wolf { background-color: brown; }
    .bear { background-color: black; }
    .fox { background-color: orange; }

    /* UI Overlay and Inventory styles remain the same as previous response */
    #uiContainer { display: flex; flex-direction: column; width: 600px; }
    .status-bar-container { width: 100%; height: 20px; background-color: rgba(0, 0, 0, 0.5); border: 1px solid white; margin-bottom: 5px; position: relative; }
    .status-bar-fill { height: 100%; transition: width 0.3s ease-out; }
    .status-bar-label { position: absolute; top: 0; left: 0; width: 100%; text-align: center; line-height: 20px; font-size: 12px; text-shadow: 1px 1px 1px black; }
    #hp-fill { background-color: red; }
    #hunger-fill { background-color: orange; }
    #inventory { display: grid; grid-template-columns: repeat(9, 60px); gap: 5px; width: 600px; height: 60px; background-color: rgba(0, 0, 0, 0.5); padding: 5px; border: 2px solid white; }
    .inv-slot { width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.1); border: 1px solid white; position: relative; cursor: pointer; }
    .inv-slot:hover { background-color: rgba(255, 255, 255, 0.3); }
    .item-icon { width: 80%; height: 80%; margin: 10% auto; }
    .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: white; text-shadow: 1px 1px 1px black; }
  </style>
</head>
<body>
  <div id="gameArea">
    <div id="box"></div>
  </div>

  <div id="uiContainer">
    <div class="status-bar-container">
        <div id="hp-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HP: <span id="hp-value">100</span>/100</div>
    </div>
    <div class="status-bar-container">
        <div id="hunger-fill" class="status-bar-fill"></div>
        <div class="status-bar-label">HUNGER: <span id="hunger-value">100</span></div>
    </div>
    <div id="inventory"></div>
  </div>

  <script>
    const gameArea = document.getElementById("gameArea");
    const box = document.getElementById("box");
    const inventoryEl = document.getElementById("inventory");
    const hpFillEl = document.getElementById("hp-fill");
    const hpValueEl = document.getElementById("hp-value");
    const hungerFillEl = document.getElementById("hunger-fill");
    const hungerValueEl = document.getElementById("hunger-value");
    const step = 20;
    const INVENTORY_SIZE = 9;
    const GRID_SIZE = 40; // Player/enemy size for movement calculations

    let boxX = 280;
    let boxY = 180;
    let roomX = 0;
    let roomY = 0;
    const rooms = {};
    let lastHitTime = 0; // Timestamp of the last time player was hit

    const player = {
        hp: 100,
        maxHp: 100,
        hunger: 100,
        maxHunger: 100,
        inventory: {}
    };

    // --- Configs ---
    const resourceConfig = {
      tree: { max: 30, regen: 5000, color: 'green', type: 'material' },
      rock: { max: 20, regen: 10000, color: 'gray', type: 'material' },
      gold: { max: 10, regen: 20000, color: 'gold', type: 'material' },
      diamond: { max: 10, regen: 20000, color: 'cyan', type: 'material' },
      berrybush: { max: 6, regen: 8000, color: 'darkred', type: 'food', foodValue: 10 }
    };

    const enemyConfig = {
        wolf: { hp: 200, damage: 10, speed: 10, range: 100, drops: { meat: 1 } },
        bear: { hp: 350, damage: 20, speed: 5, range: 100, drops: { meat: 2, fur: 1 } },
        fox: { hp: 200, damage: 10, speed: 15, range: 100, drops: { meat: 1 } }
    };
    // Add color for item icons
    resourceConfig['meat'] = { color: 'pink', type: 'food', foodValue: 20 };
    resourceConfig['fur'] = { color: 'white', type: 'material' };

    // --- UI Update Functions ---
    function updateHPUI() {
        hpValueEl.textContent = player.hp;
        const percent = (player.hp / player.maxHp) * 100;
        hpFillEl.style.width = percent + "%";
        if (player.hp <= 0) alert("You died!");
    }
    // ... updateHungerUI and updateInventoryUI functions are the same as before ...
    function updateHungerUI() {
        hungerValueEl.textContent = player.hunger;
        const percent = (player.hunger / player.maxHunger) * 100;
        hungerFillEl.style.width = percent + "%";
    }

    function updateInventoryUI() {
        inventoryEl.innerHTML = '';
        const items = Object.entries(player.inventory);
        for (let i = 0; i < INVENTORY_SIZE; i++) {
            const slot = document.createElement("div");
            slot.className = "inv-slot";
            slot.dataset.index = i;
            if (i < items.length) {
                const [type, count] = items[i];
                if (count > 0) {
                    const icon = document.createElement("div");
                    icon.className = `item-icon ${type}`;
                    icon.style.backgroundColor = resourceConfig[type].color;
                    slot.appendChild(icon);
                    const countSpan = document.createElement("span");
                    countSpan.className = "item-count";
                    countSpan.textContent = count;
                    slot.appendChild(countSpan);
                    slot.dataset.type = type;
                }
            }
            inventoryEl.appendChild(slot);
        }
    }

    // --- Interaction Logic ---
    function eatItem(itemType) {
        const config = resourceConfig[itemType];
        if (config && config.type === 'food' && player.inventory[itemType] > 0) {
            player.inventory[itemType]--;
            player.hunger += config.foodValue;
            if (player.hunger > player.maxHunger) player.hunger = player.maxHunger;
            if (player.inventory[itemType] <= 0) delete player.inventory[itemType];
            updateHungerUI();
            updateInventoryUI();
        } else if (config.type === 'material') {
            console.log(`Can't eat ${itemType}!`);
        }
    }

    inventoryEl.addEventListener('click', (event) => {
        const clickedSlot = event.target.closest('.inv-slot');
        if (clickedSlot && clickedSlot.dataset.type) {
            eatItem(clickedSlot.dataset.type);
        }
    });

    function collectResource(type, amount) {
        if (player.inventory[type]) player.inventory[type] += amount;
        else player.inventory[type] = amount;
        updateInventoryUI();
    }

    function damagePlayer(amount) {
        player.hp -= amount;
        lastHitTime = Date.now(); // Record the time of the hit
        updateHPUI();
    }

    // --- Game World Generation/Persistence (Obstacles) ---

    function placeObstacle(type, count, obstacles) {
      const cfg = resourceConfig[type];
      for (let i = 0; i < count; i++) {
        const obs = document.createElement("div");
        obs.className = type;
        obs.style.left = Math.floor(Math.random() * (gameArea.offsetWidth - GRID_SIZE)) + "px";
        obs.style.top = Math.floor(Math.random() * (gameArea.offsetHeight - GRID_SIZE)) + "px";
        obs.dataset.type = type;
        obs.dataset.amount = cfg.max;
        obs.style.backgroundColor = cfg.color;
        obstacles.push(obs);
      }
    }

    // --- Enemy Management ---
    function createEnemy(type, x, y) {
        const config = enemyConfig[type];
        const enemyEl = document.createElement("div");
        enemyEl.className = `enemy ${type}`;
        enemyEl.style.left = x + "px";
        enemyEl.style.top = y + "px";
        // Store data within the element for AI loop
        enemyEl.dataset.type = type;
        enemyEl.dataset.hp = config.hp;
        enemyEl.dataset.maxHp = config.hp;
        enemyEl.textContent = `${type} (${config.hp})`;
        return enemyEl;
    }

    function placeEnemies(enemies) {
        // Place 1-2 wolves, 1 bear occasionally, foxes occasionally
        if (Math.random() < 0.75) enemies.push(createEnemy('wolf', 100, 100));
        if (Math.random() < 0.25) enemies.push(createEnemy('wolf', 500, 300));
        if (Math.random() < 0.15) enemies.push(createEnemy('bear', 300, 200));
        if (Math.random() < 0.5) enemies.push(createEnemy('fox', 400, 100));
    }
    
    // Updated generateRoom to include enemies
    function generateRoom(rx, ry) {
      const key = `${rx},${ry}`;
      if (rooms[key]) return rooms[key];

      const roomData = { obstacles: [], enemies: [], intervals: [] }; // Added enemies array
      placeObstacle("tree", Math.floor(Math.random() * 3) + 2, roomData.obstacles);
      placeObstacle("rock", Math.floor(Math.random() * 2) + 1, roomData.obstacles);
      if (Math.random() < 0.25) placeObstacle("gold", 1, roomData.obstacles);
      if (Math.random() < 0.05) placeObstacle("diamond", 1, roomData.obstacles);
      placeObstacle("berrybush", Math.floor(Math.random() * 3) + 1, roomData.obstacles);

      placeEnemies(roomData.enemies); // Add enemies when room is first generated

      rooms[key] = roomData;
      return roomData;
    }

    // Updated clearRoom to remove enemies and stop AI intervals
    function clearRoom() {
      const key = `${roomX},${roomY}`;
      const currentRoomData = rooms[key];

      if (currentRoomData) {
          // Remove obstacles
          currentRoomData.obstacles.forEach(child => {
              if (child.parentNode === gameArea) gameArea.removeChild(child);
          });
          // Remove enemies
          currentRoomData.enemies.forEach(child => {
              if (child.parentNode === gameArea) gameArea.removeChild(child);
          });
          // Stop intervals
          currentRoomData.intervals.forEach(clearInterval);
          currentRoomData.intervals = [];
      }
    }

    // Updated loadRoom to append enemies
    function loadRoom(rx, ry) {
      const roomData = generateRoom(rx, ry);

      roomData.obstacles.forEach(obs => {
        gameArea.appendChild(obs);
        const cfg = resourceConfig[obs.dataset.type];
        const intervalId = setInterval(() => {
          let amt = parseInt(obs.dataset.amount);
          if (amt < cfg.max) obs.dataset.amount = amt + 1;
        }, cfg.regen);
        roomData.intervals.push(intervalId);
      });
      
      // Append enemies to the game area
      roomData.enemies.forEach(enemy => {
          if (enemy.dataset.hp > 0) { // Only append alive enemies
              gameArea.appendChild(enemy);
          }
      });
    }

    // Collision check function (needs to check against obstacles AND other enemies)
    function checkCollision(x, y, items) {
        const rect1 = {x, y, w: GRID_SIZE, h: GRID_SIZE};
        for (const item of items) {
            // Check if item is still in the DOM and is an obstacle/enemy
            if (item.parentNode === gameArea) {
                const rect2 = item.getBoundingClientRect();
                const areaRect = gameArea.getBoundingClientRect();
                const ox = rect2.left - areaRect.left;
                const oy = rect2.top - areaRect.top;
                const ow = rect2.width;
                const oh = rect2.height;

                if (rect1.x < ox + ow && rect1.x + rect1.w > ox && rect1.y < oy + oh && rect1.y + rect1.h > oy) {
                    return true; // Collision detected
                }
            }
        }
        return false;
    }

    function canMovePlayer(newX, newY) {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        // Combine obstacles and live enemies for collision check
        const allCollidables = [...currentRoomData.obstacles, ...currentRoomData.enemies.filter(e => e.dataset.hp > 0)];
        return !checkCollision(newX, newY, allCollidables);
    }
    
    // --- Core Game Loops and Handlers ---

    // Initial setup
    loadRoom(roomX, roomY);
    updateHPUI();
    updateHungerUI();
    updateInventoryUI();

    // Hunger depletion loop (45 seconds)
    setInterval(() => {
        if (player.hunger > 0) {
            player.hunger -= 10;
            if (player.hunger < 0) player.hunger = 0;
            updateHungerUI();
        }
    }, 45000);

    // Damage/Regen loop (3 seconds)
    setInterval(() => {
        if (player.hunger === 0 && player.hp > 0) {
            damagePlayer(10); // Damage every 3 seconds if starving
        }
        
        // Healing mechanic: 5 HP every tick if not hit for 5s AND above 70% HP
        if (Date.now() - lastHitTime >= 5000 && player.hp > player.maxHp * 0.70 && player.hp < player.maxHp) {
            player.hp += 5;
            if (player.hp > player.maxHp) player.hp = player.maxHp;
            updateHPUI();
        }
    }, 3000);


    // AI Update Loop (~0.5 seconds for all enemies in the room)
    setInterval(() => {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        if (!currentRoomData) return;

        currentRoomData.enemies.forEach(enemy => {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) return; // Skip dead/unloaded enemies

            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);
            const dx = boxX - eX;
            const dy = boxY - eY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const config = enemyConfig[enemy.dataset.type];

            if (distance < config.range) {
                // Chase behavior: Move toward the player
                let moveX = 0;
                let moveY = 0;
                // Simple AI: move one step closer on the axis with the greatest distance
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = Math.sign(dx) * GRID_SIZE;
                } else {
                    moveY = Math.sign(dy) * GRID_SIZE;
                }
                
                let newEX = eX + moveX;
                let newEY = eY + moveY;

                // Check collision for enemy movement (against obstacles/other enemies/player)
                const allCollidablesExceptSelfAndPlayer = [...currentRoomData.obstacles, ...currentRoomData.enemies.filter(e => e !== enemy && e.dataset.hp > 0)];
                
                // If the intended move collides with a wall or another enemy, try moving the other axis instead
                if (checkCollision(newEX, newEY, allCollidablesExceptSelfAndPlayer)) {
                    moveX = 0;
                    moveY = 0;
                    if (Math.abs(dx) <= Math.abs(dy)) { // Try the secondary axis
                         moveX = Math.sign(dx) * GRID_SIZE;
                    } else {
                         moveY = Math.sign(dy) * GRID_SIZE;
                    }
                    newEX = eX + moveX;
                    newEY = eY + moveY;
                }

                // Final collision check before moving
                if (!checkCollision(newEX, newEY, allCollidablesExceptSelfAndPlayer)) {
                    enemy.style.left = newEX + "px";
                    enemy.style.top = newEY + "px";
                }
                // Attacking happens in a separate loop/handler, just move here
            }
        });
    }, 500); // AI update every half second

    // Enemy Attack loop (Every 3 seconds, consistent with player punch/damage tick)
    setInterval(() => {
        const currentRoomData = rooms[`${roomX},${roomY}`];
        if (!currentRoomData || player.hp <= 0) return;

        currentRoomData.enemies.forEach(enemy => {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) return;

            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);
            const config = enemyConfig[enemy.dataset.type];

            // Check if adjacent (attack range is same as one movement step/grid size)
            const dx = Math.abs(boxX - eX);
            const dy = Math.abs(boxY - eY);
            // Allow diagonal attack proximity check (within 40px square of player center)
            if (dx < GRID_SIZE * 1.5 && dy < GRID_SIZE * 1.5 && dx + dy > 0) { 
                damagePlayer(config.damage);
                console.log(`${enemy.dataset.type} attacked you for ${config.damage} damage!`);
            }
        });
    }, 3000);


    // Movement and Room Change Handler
    document.addEventListener("keydown", (event) => {
      let newX = boxX;
      let newY = boxY;
      let roomChanged = false;

      if (event.key === "ArrowUp") newY -= step;
      else if (event.key === "ArrowDown") newY += step;
      else if (event.key === "ArrowLeft") newX -= step;
      else if (event.key === "ArrowRight") newX += step;
      else if (event.code !== "Space") return;

      // Check if off screen (room transitions)
      if (newX < 0) { clearRoom(); roomX--; newX = gameArea.offsetWidth - 40; roomChanged = true; }
      else if (newX > gameArea.offsetWidth - 40) { clearRoom(); roomX++; newX = 0; roomChanged = true; }
      else if (newY < 0) { clearRoom(); roomY--; newY = gameArea.offsetHeight - 40; roomChanged = true; }
      else if (newY > gameArea.offsetHeight - 40) { clearRoom(); roomY++; newY = 0; roomChanged = true; }

      if (roomChanged) loadRoom(roomX, roomY);

      if (canMovePlayer(newX, newY)) {
        boxX = newX;
        boxY = newY;
        box.style.left = boxX + "px";
        box.style.top = boxY + "px";
      }
    });
    
    // Punch Mechanic Handler (Attacking enemies)
    document.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        const obstacles = rooms[`${roomX},${roomY}`].obstacles || [];
        const enemies = rooms[`${roomX},${roomY}`].enemies || [];
        const punchDamage = 10;

        // Check obstacles (resources)
        for (const obs of obstacles) {
          const rect = obs.getBoundingClientRect();
          const areaRect = gameArea.getBoundingClientRect();
          const ox = rect.left - areaRect.left;
          const oy = rect.top - areaRect.top;
          // Check proximity
          if (Math.abs(boxX - ox) < 50 && Math.abs(boxY - oy) < 50) { 
            let amt = parseInt(obs.dataset.amount);
            if (amt > 0) {
              obs.dataset.amount = amt - 1;
              collectResource(obs.dataset.type, 1);
            }
          }
        }
        
        // Check enemies
        for (const enemy of enemies) {
            if (enemy.dataset.hp <= 0 || enemy.parentNode !== gameArea) continue;

            const eX = parseInt(enemy.style.left);
            const eY = parseInt(enemy.style.top);

            if (Math.abs(boxX - eX) < 50 && Math.abs(boxY - eY) < 50) {
                let hp = parseInt(enemy.dataset.hp);
                hp -= punchDamage;
                enemy.dataset.hp = hp;
                console.log(`Dealt ${punchDamage} to ${enemy.dataset.type}. Remaining HP: ${hp}`);
                enemy.textContent = `${enemy.dataset.type} (${hp})`; // Update HP label

                if (hp <= 0) {
                    // Enemy dies, remove from DOM and grant drops
                    gameArea.removeChild(enemy);
                    console.log(`${enemy.dataset.type} defeated!`);
                    const drops = enemyConfig[enemy.dataset.type].drops;
                    for (const dropType in drops) {
                        collectResource(dropType, drops[dropType]);
                    }
                }
                // Only hit one enemy/resource per punch
                break; 
            }
        }
      }
    });
  </script>
</body>
</html>
